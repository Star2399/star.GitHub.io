<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://star2399.github.io</id>
    <title>Star的个人博客</title>
    <updated>2022-10-06T08:12:05.379Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://star2399.github.io"/>
    <link rel="self" href="https://star2399.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://star2399.github.io/images/avatar.png</logo>
    <icon>https://star2399.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Star的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[10/6 讯飞技术一面]]></title>
        <id>https://star2399.github.io/post/106-xun-fei-ji-zhu-yi-mian/</id>
        <link href="https://star2399.github.io/post/106-xun-fei-ji-zhu-yi-mian/">
        </link>
        <updated>2022-10-06T07:59:20.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>一开始自我介绍，问怎么学的前端</li>
<li>疯狂问项目，问场景题</li>
<li>call和apply区别</li>
<li>js事件</li>
<li>addEventListener的参数，第三个参数除了boolean还可以是什么</li>
<li>如何隐藏一个元素，透明度设置为0以后会触发重绘吗？</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[URI]]></title>
        <id>https://star2399.github.io/post/uri/</id>
        <link href="https://star2399.github.io/post/uri/">
        </link>
        <updated>2022-10-06T02:45:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>URI（Uniform Resource Identifier，统一资源标识符）</p>
</blockquote>
<ul>
<li>URI包含URL(统一资源定位符)和URN(统一资源名称)</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://star2399.github.io/post-images/1665024463080.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebPack笔记]]></title>
        <id>https://star2399.github.io/post/webpack-bi-ji/</id>
        <link href="https://star2399.github.io/post/webpack-bi-ji/">
        </link>
        <updated>2022-10-02T05:03:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-引入">一、引入</h1>
<h2 id="11-为什么需要webpack">1.1 为什么需要webpack</h2>
<ul>
<li>一个html要引入太多js</li>
<li>使用一个js引入其他多个js时会存在如下问题：</li>
</ul>
<ol>
<li>作用域问题</li>
<li>文件太大</li>
<li>可读性差</li>
<li>可维护性弱</li>
</ol>
<h2 id="12-如何解决作用域问题">1.2 如何解决作用域问题</h2>
<ul>
<li>grunt和gulp使用立即调用函数表达式（IIFE）来解决</li>
</ul>
<pre><code>(function (){
	var name=&quot;ss&quot;
})()
console.log(name)//无法打印

var exportname=(function (){
	var name=&quot;ss&quot;
	return name
})()//可以打印
console.log(exportname)

</code></pre>
<h2 id="13-如何解决代码拆分">1.3 如何解决代码拆分</h2>
<ul>
<li>为了使用一个方法加载一整个文件，消耗很大</li>
<li>可以使用js模块化（es6模块化）来进行，但是有的浏览器不太支持</li>
<li>使用webpack，支持es6模块化和commonJs</li>
</ul>
<h2 id="14-webpack竞品">1.4 webpack竞品</h2>
<ul>
<li>Parcel</li>
<li>vite（最新）</li>
<li>rollup</li>
</ul>
<h1 id="二-webpack基础应用">二、WebPack基础应用</h1>
<h2 id="21-webpack安装">2.1 webpack安装</h2>
<h3 id="全局安装">全局安装</h3>
<p><code>npm i webpack webpack-cli -g</code></p>
<h3 id="本地安装推荐">本地安装（推荐）</h3>
<p>首先使用 <code>npm init -y</code> 初始化项目<br>
<code>npm i webpack webpack-cli --save-dev</code></p>
<h2 id="22-运行">2.2 运行</h2>
<h3 id="使用全局webpack">使用全局webpack</h3>
<p><code>webpack</code></p>
<h3 id="使用本地webpack">使用本地webpack</h3>
<p><code>npx webpack</code></p>
<h2 id="23-自定义webpack配置">2.3 自定义webpack配置</h2>
<ul>
<li>使用<code>npx webpack --help</code>查看命令</li>
<li>但命令行不方便，可以使用配置文件</li>
<li>在项目根目录创建webpack.config.js(不能改名)</li>
</ul>
<h3 id="配置文件">配置文件</h3>
<pre><code>const path = require('path')
module.exports = {
	entry: './src/index.js',
	output: {
		filename: 'app.js',
		path: path.resolve(__dirname, 'dist')
	},
	module: {
		rules: [

		]
	},
	plugins: [

	],
	mode: 'development'
}

</code></pre>
<h2 id="24-核心概念">2.4 核心概念</h2>
<h3 id="entry-入口">Entry 入口</h3>
<p>指示 Webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。</p>
<h3 id="output-输出">Output 输出</h3>
<p>指示 Webpack 打包后的资源 bundles 输出到哪里，以及如何命名。</p>
<pre><code>module.exports = {
  ...
  output: {
    // 输出文件名称
    filename: 'app.js',
    // 输出文件路径
    path: path.resolve(__dirname, 'dist'),
    // 删除不需要的旧文件
    clean: true
  }
}
</code></pre>
<h3 id="module">module</h3>
<p>用于资源模块的打包</p>
<h3 id="loader-解析器">Loader 解析器</h3>
<ul>
<li>webpack只能理解js和json</li>
<li>让 Webpack 能够去处理那些非 JavaScript 文件 ( Webpack 自身只理解 JavaScript )。</li>
</ul>
<h3 id="plugins-插件">Plugins 插件</h3>
<p>可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。</p>
<h3 id="mode-模式">Mode 模式</h3>
<p>指示 Webpack 使用相应模式的配置。</p>
<ul>
<li>development 开发模式：会将 process.env.NODE_ENV 的值设为 development。启用 NameChunksPlugin 和 NameModulesPlugin。特点是能让代码本地调试运行的环境。</li>
<li>production 生产模式：会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin。特点是能让代码优化上线运行的环境。</li>
<li>none：</li>
</ul>
<h2 id="25-devserver">2.5 devServer</h2>
<h3 id="251-使用watch-model">2.5.1 使用watch model</h3>
<p><code>npx webpack --watch</code></p>
<ul>
<li>可以事实检测代码改变并重新打包</li>
<li>但是需要手动刷新浏览器</li>
</ul>
<h3 id="252-webpack-dev-server">2.5.2 webpack-dev-server</h3>
<ul>
<li>提供了一个基本的web server</li>
<li>具有live reloading（实时重新加载）功能</li>
</ul>
<h4 id="下载-webpack-dev-server">下载 webpack-dev-server</h4>
<p><code>npm i webpack-dev-server -D</code></p>
<h4 id="配置">配置</h4>
<pre><code>  devServer: {
    // 环境目录
    static: path.resolve(__dirname,'./dist'),
    // 设置是不是在服务器端进行代码 gzip 压缩，提高传输效率
    compress: true,
    // 设置服务器主机
    host: '0.0.0.0',
    // 设置端口号
    port: 3000,
    // 设置路由
    historyApiFallback: true,
    // 自动打开页面
    open: true,
    // 更改后自动更新
    watchFiles: {
      paths: [
        './*'
      ],
      options: {
        usePolling: false
      }
    },
    // 启用热加载功能
    liveReload: true,
    // 启用热模块功能
    hot: true，
    //设置响应头
    headers:{
        'X-Access-Token':'abc123'
    },
    //设置代理
    proxy:{
        '/api':'http://localhost:9000'
    },
    //配置https,让本地的http服务变成https服务
    https:true,
     //配置http2，http2自带https签名证书，我们仍然可以通过htps配置项来使用
    http2:true,
}
</code></pre>
<h4 id="启动">启动</h4>
<p><code>npx webpack-dev-server</code></p>
<h4 id="注意">注意</h4>
<p>webpack-dev-server不生成文件，而是保存在内存中，使得编译效率提高<br>
在 webpack.config.js 文件中进行配置</p>
<h2 id="26-资源模块">2.6 资源模块</h2>
<ul>
<li>webpack除了引入js还可以使用内置的资源模块</li>
<li>asset modules（资源模块）</li>
</ul>
<h3 id="261-资源模块分类">2.6.1 资源模块分类</h3>
<ul>
<li>asset/resource：发送一个单独的文件并导出 URL</li>
<li>asset/inline：导出一个资源的 Data URI ( 64位图 )</li>
<li>asset/source：导出资源的源代码</li>
<li>asset：在导出一个资源的 Data URI 和发送一个单独的文件之间自动进行选择</li>
</ul>
<h3 id="262-resource">2.6.2 resource</h3>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.png$/i,
        // 设置资源类型
        type: 'asset/resource',
        generator: {
          // 生成资源名称
          filename: 'assets/images/[name][ext]'
        }
      }
    ]
  }
}
</code></pre>
<ul>
<li>
<p>资源名称可以使用 [contenthash][ext] 将资源名称生成为 hash 值命名</p>
</li>
<li>
<p>还可以使用另一种方式打包，在output里面配置，但是generator优先级高</p>
</li>
</ul>
<pre><code>	output: {
		filename: 'app.js',
		path: path.resolve(__dirname, 'dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[name][ext]&quot;
	},
</code></pre>
<h3 id="263-inline">2.6.3 inline</h3>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.svg$/i,
        // 设置资源类型
        type: 'asset/inline'
      }
    ]
  }
}
</code></pre>
<h3 id="264-source">2.6.4 source</h3>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.txt$/i,
        // 设置资源类型
        type: 'asset/source'
      }
    ]
  }
}
</code></pre>
<h3 id="265-asset">2.6.5 asset</h3>
<ul>
<li>选择的依据是资源大小</li>
<li>默认情况下，资源大于8k使用asset/resource创建一个资源，小于8k，作为asset/inline生成base64的链接</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.jpg$/i,
        // 设置资源类型
        type: 'asset',
        // 小于设置的大小则转为 64 位图，否则转 URL
        parser: {
          dataUrlCondition: {
            maxSize: 4 * 1024 // 4kb
          }
        },
        generator: {
          // 生成资源名称
          filename: 'assets/images/[name][ext]'
        }
      }
    ]
  }
}
</code></pre>
<h2 id="27-资源处理">2.7 资源处理</h2>
<h3 id="271-html资源">2.7.1 HTML资源</h3>
<ol>
<li>下载 html-webpack-plugin 插件</li>
</ol>
<p><code>npm i html-webpack-plugin - D</code></p>
<ol start="2">
<li>在 webpack.config.js 文件中引入插件并调用</li>
</ol>
<pre><code>// 引用插件
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  ...
  plugins: [
    // 打包 HTML 文件
    new HtmlWebpackPlugin({
      // 指定 HTML 模版文件
      template: './index.html',
      //指定文件名
      filename:'app.html',
      // 指定 Script 标签位置
      inject: 'body'，
      //通过配置chunks来调整html引入的js
      chunks:['main']
    })
  ]
}
</code></pre>
<ul>
<li>Webpack 会在输出目录中新创建一个 HTML 文件，在原始的 HTML 文件中无需引入 JS 文件，通过 Webpack 编译后的 HTML 文件会自动引入。</li>
</ul>
<ol start="3">
<li>多页面环境</li>
</ol>
<ul>
<li>不同页面的filename必须不同</li>
<li>使用chunks指定引入不同的js</li>
</ul>
<pre><code>const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  ...
  plugins: [
    // 打包 HTML 文件
    new HtmlWebpackPlugin({
      template: './index.html',
      filename:'app.html',
      inject: 'body'，
      chunks:['main']，
      publicPath:'http://www.b.com'
    }),
      new HtmlWebpackPlugin({
      template: './index2.html',
      filename:'app2.html',
      inject: 'body'，
      chunks:['main2'],
      publicPath:'http://www.a.com'
    })
  ]
}
</code></pre>
<ul>
<li>还可以对打包好的的js路径进行</li>
</ul>
<pre><code>entry:{
    main:{
        import:['./src/app2.js','./src/app.js'],
        dependOn:'loadsh',
        filename:'chanel1/[name].js'
    },
    main:{
        import:['./src/app3.js'],
        dependOn:'loadsh',
        filename:'chanel2/[name].js'
    },
    lodash:{
        import:'lodash',
        filename:'common/[name].js'
    }
}
</code></pre>
<h3 id="272-样式资源">2.7.2 样式资源</h3>
<h4 id="打包css">打包css</h4>
<ul>
<li>下载样式处理解析器 css-loader 与 style-loader</li>
</ul>
<p><code>npm i css-loader style-loader -D</code></p>
<ul>
<li>在配置文件中添加解析器</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          // 在 head 中创建 style 标签
          'style-loader',
          // 将 css 文件整合到 js 文件中
          'css-loader'
        ]
      }
    ]
  }
}
</code></pre>
<ul>
<li>
<p>css-loader和style-loader的顺序不能颠倒，先执行css-loader，在执行style-loader。从后往前，webpack支持loader的链式调用，链式的每一个loader都可以对我们的源进行转换，且转换是逆序的</p>
</li>
<li>
<p>在 JS 文件中导入 CSS 文件</p>
</li>
</ul>
<p><code>import '../css/main.css'</code></p>
<h4 id="打包less">打包less</h4>
<ul>
<li>下载样式处理解析器 css-loader 与 style-loader</li>
</ul>
<p><code>npm i less-loader less -D</code></p>
<ul>
<li>在配置文件中添加解析器</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.(css|less)$/i,
        use: [
          // 在 head 中创建 style 标签
          'style-loader',
          // 将 css 文件整合到 js 文件中
          'css-loader',
         // 编译 less 文件为 css 文件
          'less-loader'
        ]
      }
    ]
  }
}
</code></pre>
<ul>
<li>在 JS 文件中导入 less文件</li>
</ul>
<p><code>import '../css/main.less'</code></p>
<h4 id="抽离和压缩css">抽离和压缩css</h4>
<p>抽离</p>
<ul>
<li>下载插件 mini-css-extract-plugin</li>
</ul>
<p><code>npm i mini-css-extract-plugin -D</code></p>
<ul>
<li>引用插件</li>
</ul>
<pre><code>const MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.s[ac]ss$/i,
        use: [
          // 抽离 css 为独立文件
          MiniCssExtractPlugin.loader,
          // 将 css 文件整合到 js 文件中
          'css-loader',
          // 编译 sass 文件为 css 文件
          'sass-loader'
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      // 对输出结果重命名
      filename: 'assets/css/[name].css'
    })
  ]
}
</code></pre>
<p>压缩</p>
<ul>
<li>
<p>安装插件 css-minimizer-webpack-plugin<br>
<code>npm i css-minimizer-webpack-plugin -D</code></p>
</li>
<li>
<p>在配置文件中进行配置</p>
</li>
</ul>
<pre><code>const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;)

module.exports = {
  ...
  optimization: {
    minimizer: [
      // 使用插件优化 css 代码
      new CssMinimizerPlugin()
    ],
  },
  // 模式
  mode: 'production'
}
</code></pre>
<ul>
<li>压缩 CSS 代码，仅在生产模式下有效</li>
<li>如果使用了css压缩，webpack开箱即用的terser会失效，那么要进行js压缩还要引入terser</li>
</ul>
<p>安装terser<br>
<code>npm install terser-webpack-plugin -D</code><br>
配置</p>
<pre><code>const TerserPlugin = require('terser-webpack-plugin')
	optimization: {
        minimizer:[
            new CssMinimizerPlugin(),
            new TerserPlugin()
        ]
		}
</code></pre>
<h3 id="273-css中加载图片资源">2.7.3 css中加载图片资源</h3>
<h3 id="274-加载fonts字体">2.7.4 加载fonts字体</h3>
<ul>
<li>通过 CSS 引入字体资源</li>
</ul>
<pre><code>@font-face {
  font-family: 'iconfont';
  src:url('../fonts/PujiSans-ExpandedHeavy.ttf') format('truetype')
}
.icon{
    font-family:'iconfont';
    font-size:30px;
}
</code></pre>
<ul>
<li>在 webpack.config.js 文件中进行配置</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        // 设置资源类型
        type: 'asset/resource',
        generator: {
          // 生成资源名称
          filename: 'assets/fonts/[name][ext]'
        },
      }
    ]
  }
}
</code></pre>
<h3 id="275-加载数据">2.7.5 加载数据</h3>
<ul>
<li>安装插件</li>
</ul>
<p><code>npm i csv-loader xml-loader -D</code></p>
<ul>
<li>添加配置</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
          test:/\.(csv|tsv)$/,
          use:'csv-loader'
      },
      {
           test:/\.xml)$/,
           use:'xml-loader'
      }
    ]
  }
}
</code></pre>
<ul>
<li>.xml会转换为一个对象，.csv会转换为数组</li>
</ul>
<h3 id="276-自定义json模块">2.7.6 自定义json模块</h3>
<ul>
<li>安装</li>
</ul>
<p><code>npm i toml yaml json5 -D</code></p>
<ul>
<li>引入</li>
</ul>
<pre><code>const toml = require('toml')
const yaml = require('yaml')
const json5 = require('json5')
</code></pre>
<ul>
<li>添加配置</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
          test:/\.toml$/,
          type:'json',
          parser:{
              parse:toml.parse
          }
      },
      {
          test:/\.yaml$/,
          type:'json',
          parser:{
              parse:yaml.parse
          }
      },
            {
          test:/\.json5$/,
          type:'json',
          parser:{
              parse:json5.parse
          }
      }
    ]
  }
}
</code></pre>
<h3 id="277-js资源">2.7.7 js资源</h3>
<h4 id="2771-js兼容处理">2.7.7.1 js兼容处理</h4>
<p>将 ES6 代码转换为低版本 ES 代码</p>
<p>安装模块</p>
<ul>
<li>babel-loader： 在 webpack 里应用 babel 解析 ES6 的桥梁</li>
<li>@babel/core： babel 核心模块</li>
<li>@babel/preset-env： babel 预设，一组 babel 插件的集合</li>
</ul>
<p><code>npm i babel-loader @babel/core @babel/preset-env -D</code><br>
在 package.json 中配置</p>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.js$/,
        // 排除 node_modules 中安装的库
        exclude: /(node_modules|bower_components)/,
        use: {
          // 加载 loader
          loader: 'babel-loader',
          options: {
            // 配置预设
            presets: ['@babel/preset-env']
          }
        }
      }
    ]
  }
}
</code></pre>
<h4 id="2772-regeneratorruntime">2.7.7.2 regeneratorRuntime</h4>
<ul>
<li>regeneratorRuntime 是 webpack 打包生成的全局辅助函数，由 babel 生成，用于兼容 async/await 的语法。<br>
<code>npm i @babel/runtime @babel/plugin-transform-runtime -D</code></li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.m?js$/,
        // 排除 node_modules 中安装的库
        exclude: /(node_modules|bower_components)/,
        use: {
          // 加载 loader
          loader: 'babel-loader',
          options: {
            // 配置预设
            presets: ['@babel/preset-env']
            plugins: [
              [
                '@babel/plugin-transform-runtime'
              ]
            ]
          }
        }
      }
    ]
  }
}
</code></pre>
<h4 id="2773-js语法检查">2.7.73 js语法检查</h4>
<p>使用 eslint 扫描我们所写的代码是否符合规范，严格意义上来说，eslint 配置跟 webpack 无关，但在工程化开发环境中，他往往是不可或缺的。</p>
<p>安装<br>
<code>npm i eslint -D</code><br>
创建配置文件，根据提示选择需要的类型。配置完成后，将在 node_modules 文件夹中生成一个 .eslintrc.json 文件，将文件复制到根目录下。<br>
<code>npx eslint --init</code><br>
<img src="https://star2399.github.io/post-images/1664709198238.png" alt="" loading="lazy"><br>
在 VSCode 中安装扩展 Eslint ，重启软件后将自动生效。</p>
<h4 id="2774-js-压缩">2.7.7.4 JS 压缩</h4>
<p>安装插件 terser-webpack-plugin</p>
<p><code>npm i terser-webpack-plugin -D</code></p>
<p>配置</p>
<pre><code>const TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;)

module.exports = {
  ...
  optimization: {
    minimizer: [
      // 使用插件压缩 js 代码 (生产模式)
      new TerserWebpackPlugin()
    ]
  }
}
</code></pre>
<h2 id="28-代码分离">2.8 代码分离</h2>
<ul>
<li>代码分离是webpack最引人注目的特性之一</li>
<li>可以把代码分离到不同的文件中</li>
<li>按需加载并行加载</li>
<li>可以获取更小的文件</li>
<li>控制资源加载的优先级</li>
</ul>
<h3 id="方法">方法</h3>
<ul>
<li>配置入口起点：使用entry手动分离代码 ，缺点是如果多个入口，那多个入口共享的文件会分别在每个包里重复打包</li>
<li>防止重复：使用Entry dependencies或者SplitChunksPlugin去重和分离代码</li>
<li>动态导入：通过模块的内联函数调用来分离代码</li>
</ul>
<h3 id="281-配置入口起点">2.8.1 配置入口起点</h3>
<ul>
<li>在src下创建新的入口文件another-module.js</li>
<li>entry配置如下：</li>
</ul>
<pre><code>entry:{
		index: './src/index.js',
		another:'./src/another-module.js'
},
</code></pre>
<ul>
<li>output配置如下</li>
</ul>
<pre><code>output: {
		filename: '[name].bundle.js',
		path: path.resolve(__dirname, 'dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[name][ext]&quot;
	}
</code></pre>
<ul>
<li>打包后发现index.html已经引入两个js且都有效</li>
<li>但是把公用的包分别打包到每个chunk里</li>
</ul>
<h3 id="282">2.8.2</h3>
<ul>
<li>entry如下编写,这样就会把公用的lodash提出来</li>
</ul>
<pre><code>	entry:{
		index: {
			import: './src/index.js',
			dependOn: 'shared'
		},
		another:{
			import: './src/another-module.js',
			dependOn: 'shared'
		},
		shared:'lodash'
	},
</code></pre>
<ul>
<li>也可以使用一个插件SplitChunksPlugin</li>
</ul>
<pre><code>    entry:{
            index: './src/index.js',
            another:'./src/another-module.js'
    },
	optimization: {
		splitChunks: {
			chunks: &quot;all&quot;
		}
	}
</code></pre>
<h3 id="283-动态导入">2.8.3 动态导入</h3>
<ul>
<li>编写async-module.js,动态导入lodash</li>
</ul>
<pre><code>function getComponment(){
	return import(/*webpackChunkName:'lodash'*/'lodash').then(({default:_})=&gt;{
		const element = document.createElement('div')
		element.innerHTML = _.join(['dasdasd','rrrrr'],' ')
		return element
	})
}

getComponment().then((element)=&gt;{
	document.body.appendChild(element)
})

</code></pre>
<ul>
<li>配置文件</li>
</ul>
<pre><code>	entry:{
		index: './src/index.js',
	},
</code></pre>
<ul>
<li>当又有静态资源时,打开如下配置：</li>
</ul>
<pre><code>	optimization: {
		splitChunks: {
			chunks: &quot;all&quot;
		}
	}
</code></pre>
<h3 id="284-动态加载应用-懒加载">2.8.4 动态加载应用-懒加载</h3>
<ul>
<li>编写math.js</li>
</ul>
<pre><code>export const add = (x,y)=&gt;{
	return x+y
}
export const minus = (x,y)=&gt;{
	return x-y
}

</code></pre>
<ul>
<li>在index.js中导入并编写如下代码</li>
</ul>
<pre><code>
const button = document.createElement('button')
button.textContent='点击执行加法运算'
button.addEventListener('click',()=&gt;{
	import(/*webpackChunkName:'math'*/'./math.js').then(({add})=&gt;{
		console.log(add(4,5))
	})
})
document.body.appendChild(button)

</code></pre>
<ul>
<li>打包后发现，不点击按钮就不会加载math.bundle.js，实现了懒加载</li>
</ul>
<h3 id="285-动态加载应用-预加载">2.8.5 动态加载应用-预加载</h3>
<p>在声明import时，使用下面的内置指令：</p>
<ul>
<li>prefetch（预获取）：将来某些导航下可能需要的资源，首页面的内容都加载完毕以后且网络空闲时，就会加载，比懒加载优秀</li>
</ul>
<pre><code>	import(/*webpackChunkName:'math',webpackPrefetch:true*/'./math.js').then(({add})=&gt;{
		console.log(add(4,5))
	})
</code></pre>
<ul>
<li>preload（预加载）：当前导航下可能需要的资源，和懒加载类似</li>
</ul>
<h2 id="29-缓存">2.9 缓存</h2>
<ul>
<li>在部署新版本时，不更改文件名，浏览器可能认为资源没有更新</li>
<li>本章通过一些设置，确保webpack生成的文件能被客户端缓存，在文件内容发生变化时能请求到新的文件</li>
</ul>
<h3 id="291-输出文件的文件名">2.9.1 输出文件的文件名</h3>
<p>使用contenthash，文件内容修改后文件名也会改变</p>
<pre><code>	output: {
		filename: '[name].[contenthash].js',
		path: path.resolve(__dirname, 'dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[contenthash][ext]&quot;
	},
</code></pre>
<h3 id="292-缓存第三方代码">2.9.2 缓存第三方代码</h3>
<ul>
<li>由于第三方代码保存在node_modules里，所以可以检测node_modules的代码</li>
</ul>
<pre><code>	optimization: {
		splitChunks: {
			cacheGroups: {
				vendor:{
					test: /[\\/]node_modules[\\/]/,
					name: 'vendors',
					chunks: &quot;all&quot;
				}
			}
		}
	}
</code></pre>
<h3 id="293-把所有的js放进一个文件夹里">2.9.3 把所有的js放进一个文件夹里</h3>
<pre><code>	output: {
		filename: 'scripts/[name].[contenthash].js',
		path: path.resolve(__dirname, 'dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[contenthash][ext]&quot;
	},
</code></pre>
<h2 id="210-拆分开发环境和生产环境配置">2.10 拆分开发环境和生产环境配置</h2>
<h3 id="2101-公共路径">2.10.1 公共路径</h3>
<p>在output里添加如下配置</p>
<pre><code>	output: {
		publicPath: &quot;http://localhost:8080/&quot;
	},
</code></pre>
<h3 id="2102-环境变量">2.10.2 环境变量</h3>
<ul>
<li>环境变量可以帮助我们消除webpack.config.js里面开发环境和生产环境之间的差异</li>
<li>使用环境变量需要我们把webpack.config.js暴露的对象百年城一个函数，函数返回之前的配置对象，函数接受的参数就是env</li>
</ul>
<pre><code>module.exports = (env)=&gt;{
	return {
		entry:{
		},
		output: {
		},
		devtool: 'inline-source-map',
		module: {
			rules: [
			]
		},
		plugins: [
		],
		mode: 'development',
		devServer: {
			// 环境目录
			static: './dist',
		},
		optimization: {
		}
	}

}

</code></pre>
<h3 id="2103-拆分配置文件">2.10.3 拆分配置文件</h3>
<ul>
<li>如果所有开发环境和是生产环境的区别都用三元运算符，会很麻烦</li>
<li>在项目根目录下创建config文件夹，创建webpcak.config.dev.js和webpcak.config.prod.js，代码分别如下：</li>
</ul>
<p>webpcak.config.dev.js</p>
<pre><code>// webpack.config.js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports = {
	entry:{
		index: './src/index.js',
		another:'./src/another-module.js'
	},
	output: {
		filename: 'scripts/[name].js',
		path: path.resolve(__dirname, '../dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[contenthash][ext]&quot;,
	},
	devtool: 'inline-source-map',
	module: {
		rules: [
			{
				// 监听资源文件
				test: /\.png$/i,
				// 设置资源类型
				type: 'asset/resource',
				generator: {
					// 生成资源名称
					filename: 'assets/images/[name][ext]'
				}
			},
			{
				// 监听资源文件
				test: /\.svg$/i,
				// 设置资源类型
				type: 'asset/inline'
			},
			{
				// 监听资源文件
				test: /\.txt$/i,
				// 设置资源类型
				type: 'asset/source'
			},
			{
				// 监听资源文件
				test: /\.jpg$/i,
				// 设置资源类型
				type: 'asset',
				// 小于设置的大小则转为 64 位图，否则转 URL
				parser: {
					dataUrlCondition: {
						maxSize: 4 * 1024 // 4kb
					}
				},
				generator: {
					// 生成资源名称
					filename: 'assets/images/[name][ext]'
				}
			},
			{
				test: /\.css$/i,
				use: [
					MiniCssExtractPlugin.loader,
					// 在 head 中创建 style 标签
					// 将 css 文件整合到 js 文件中
					'css-loader'
				]
			},
			{
				test: /\.js$/,
				// 排除 node_modules 中安装的库
				exclude: /(node_modules|bower_components)/,
				use: {
					// 加载 loader
					loader: 'babel-loader',
					options: {
						// 配置预设
						presets: ['@babel/preset-env'],
						plugins: [
							[
								'@babel/plugin-transform-runtime'
							]
						]
					}
				}
			}
		]
	},
	plugins: [
		new HtmlWebpackPlugin({
			// 指定 HTML 模版文件
			template: './index.html',
			// 指定 Script 标签位置
			inject: 'body'
		}),
		new MiniCssExtractPlugin({
			// 对输出结果重命名
			filename: 'assets/css/[name].css'
		})
	],
	mode: 'development',
	devServer: {
		// 环境目录
		static: './dist',
	},
	optimization: {
		splitChunks: {
			cacheGroups: {
				vendor:{
					test: /[\\/]node_modules[\\/]/,
					name: 'vendors',
					chunks: &quot;all&quot;
				}
			}
		}
	}
}
</code></pre>
<p>webpcak.config.prod.js</p>
<pre><code>// webpack.config.js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports ={
		entry:{
			index: './src/index.js',
			another:'./src/another-module.js'
		},
		output: {
			filename: 'scripts/[name].[contenthash].js',
			path: path.resolve(__dirname, '../dist'),
			clean: true,
			assetModuleFilename: &quot;assets/images/[contenthash][ext]&quot;,
			publicPath: &quot;http://localhost:8080/&quot;
		},
		module: {
			rules: [
				{
					// 监听资源文件
					test: /\.png$/i,
					// 设置资源类型
					type: 'asset/resource',
					generator: {
						// 生成资源名称
						filename: 'assets/images/[name][ext]'
					}
				},
				{
					// 监听资源文件
					test: /\.svg$/i,
					// 设置资源类型
					type: 'asset/inline'
				},
				{
					// 监听资源文件
					test: /\.txt$/i,
					// 设置资源类型
					type: 'asset/source'
				},
				{
					// 监听资源文件
					test: /\.jpg$/i,
					// 设置资源类型
					type: 'asset',
					// 小于设置的大小则转为 64 位图，否则转 URL
					parser: {
						dataUrlCondition: {
							maxSize: 4 * 1024 // 4kb
						}
					},
					generator: {
						// 生成资源名称
						filename: 'assets/images/[name][ext]'
					}
				},
				{
					test: /\.css$/i,
					use: [
						MiniCssExtractPlugin.loader,
						// 在 head 中创建 style 标签
						// 将 css 文件整合到 js 文件中
						'css-loader'
					]
				},
				{
					test: /\.js$/,
					// 排除 node_modules 中安装的库
					exclude: /(node_modules|bower_components)/,
					use: {
						// 加载 loader
						loader: 'babel-loader',
						options: {
							// 配置预设
							presets: ['@babel/preset-env'],
							plugins: [
								[
									'@babel/plugin-transform-runtime'
								]
							]
						}
					}
				}
			]
		},
		plugins: [
			new HtmlWebpackPlugin({
				// 指定 HTML 模版文件
				template: './index.html',
				// 指定 Script 标签位置
				inject: 'body'
			}),
			new MiniCssExtractPlugin({
				// 对输出结果重命名
				filename: 'assets/css/[name].css'
			})
		],
		mode:'production',
		optimization: {
			splitChunks: {
				cacheGroups: {
					vendor:{
						test: /[\\/]node_modules[\\/]/,
						name: 'vendors',
						chunks: &quot;all&quot;
					}
				}
			}
		}


}

</code></pre>
<p>分别使用命令运行:<br>
<code>npx webpack -c ./config/webpack.config.dev.js</code><br>
<code>npx webpack -c ./config/webpack.config.prod.js</code></p>
<h3 id="2104-配置npm脚本">2.10.4 配置npm脚本</h3>
<p>在项目根目录下的package.json输入如下脚本</p>
<pre><code>
{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;npx webpack -c ./config/webpack.config.dev.js&quot;,
    &quot;build&quot;: &quot;npx webpack -c ./config/webpack.config.prod.js&quot;
  }
}

</code></pre>
<p>关闭性能提示：</p>
<pre><code>	performance: {
			hints: false
	}
</code></pre>
<h3 id="2105-提取公共配置">2.10.5 提取公共配置</h3>
<ul>
<li>拆分文件，把公共部分写道webpack.config.common.js</li>
<li>其他两个文件的公共部分删除</li>
<li>安装工具</li>
</ul>
<p><code> npm install webpack-merge -D</code></p>
<ul>
<li>在config下创建webpack.config.js，编写如下配置</li>
</ul>
<pre><code>const {merge} = require('webpack-merge')

const commonConfig = require('./webpack.config.common')
const productionConfig = require('./webpack.config.prod')
const developmentConfig = require('./webpack.config.dev')

module.exports = (env)=&gt;{
	switch (true){
		case env.development:
			return merge(commonConfig,developmentConfig)
		case env.production:
			return merge(commonConfig,productionConfig)
		default:
			return new Error('No matching configuration was found')
	}
}
</code></pre>
<ul>
<li>修改package.json的script</li>
</ul>
<pre><code>  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack serve -c ./config/webpack.config.js --env development&quot;,
    &quot;build&quot;: &quot;webpack -c ./config/webpack.config.js --env production&quot;
  }
</code></pre>
<h1 id="三-webpack高级应用">三、WebPack高级应用</h1>
<h2 id="31-提高开发效率与完善团队开发规范">3.1 提高开发效率与完善团队开发规范</h2>
<h3 id="311-source-map">3.1.1 source-map</h3>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>这是默认情况，每个module会封装到eval里包裹起来执行，并在末尾追加注释//sourceURL指向未打包的文件。<strong>此时会显示webpack打包前代码的位置</strong></td>
</tr>
<tr>
<td>source-map</td>
<td>生成一个SourceMap文件，<strong>其他功能同eval</strong>。打包好的main.js最后会有一个指向该SourceMap文件的URL</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>生成一个DataUrl形式的（不是单独生成SourceMap文件）SourceMap作为注释放在打包好的js文件末尾，任然<strong>会显示webpack打包前代码的位置</strong></td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>和source-map一样。但不会在末尾追加注释，还是会生成SourceMap文件。<strong>无法显示webpack打包前代码的位置</strong></td>
</tr>
<tr>
<td>eval-source-map</td>
<td>每个module会通过eval()来执行,并且生成一个DataUrl形式的SourceMap文件 （不是单独生成SourceMap文件），<strong>会显示webpack打包前代码的位置</strong></td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>生成一个没有列信息的SourceMap文件，<strong>会显示webpack打包前代码的行位置</strong>。但是<strong>对与使用过babel解析过的代码不能定位列数</strong></td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>生成一个没有列信息的SourceMap文件，<strong>对与使用过babel解析过的代码能定位列数</strong>，开发环境推荐使用</td>
</tr>
</tbody>
</table>
<p>生产环境不推荐使用sourcemap，原因如下：</p>
<ul>
<li>通过bundle和sourcemap，可以反编译出源码，有暴露源码的风险</li>
<li>sourcemap文件的体积比较大，这和我们生产环境的追求不同</li>
</ul>
<h3 id="312-模块热替换hmr-hot-modult-replacement和热加载">3.1.2 模块热替换（HMR hot modult replacement）和热加载</h3>
<h4 id="开启热替换默认是开启的">开启热替换(默认是开启的)</h4>
<pre><code>decServer:{
    hot:true
}
</code></pre>
<ul>
<li>css热替换可以直接进行(css-loader帮助我们完成了)</li>
<li>js需要在引用需要热替换的文件中添加如下代码</li>
</ul>
<pre><code>if(module.hot){
    module.hot.accept('./input.js',()=&gt;{

    })
}
</code></pre>
<h4 id="开启热加载默认是开启的如果要关闭需要在把livereload视之为false的同时hot也设置为false">开启热加载(默认是开启的)，如果要关闭，需要在把liveReload视之为false的同时hot也设置为false</h4>
<ul>
<li>热加载相当于可以自动刷新，不用手动刷新</li>
</ul>
<pre><code>decServer:{
    liveReload:true
}
</code></pre>
<h3 id="313-eslint">3.1.3 ESLint</h3>
<ul>
<li>可以扫描i哦代码是否符合规范</li>
</ul>
<h4 id="安装">安装</h4>
<p><code>npm i eslint -D</code></p>
<h4 id="创建eslint的配置文件">创建eslint的配置文件</h4>
<p><code>npx eslint --init</code></p>
<h4 id="直接使用">直接使用</h4>
<p><code>npx eslint ./app.js</code></p>
<h4 id="配合vscode使用">配合vscode使用</h4>
<p>在vscode里安装插件</p>
<h4 id="配合webpack使用">配合webpack使用</h4>
<pre><code>module:{
    rules:[
        {
                test:/\.js$/,
                use:['babel-loader','eslint-loader']
        }
    ]
}
</code></pre>
<p>此时浏览器也会报错，如果不想浏览器显示的话，可以添加如下配置：</p>
<pre><code>devServer:{
    client:{
        overlay:false
    }
}
</code></pre>
<h3 id="314-git-hooks与husky">3.1.4 git-hooks与husky</h3>
<p>团队开发中一般在上传代码时进行校验</p>
<h4 id="git-hooks使用步骤如下">git-hooks使用步骤如下</h4>
<ul>
<li>.git文件夹下的hooks下有很多扩展名为.sample的文件</li>
<li>这些文件都是git的hook，会在git的不同生命周期调用</li>
<li>可以在pre-commit文件里面运行eslint</li>
<li>创建pre-commit    <code>touch pre-commit</code></li>
<li>编辑pre-commit    <code>npx eslint ./src</code></li>
<li>给pre-commit赋予权限，<code>chmod +x ./pre-commit</code></li>
<li>下次git再提交时就会运行pre-commit里面的命令</li>
</ul>
<p>但是，.git每个开发者都不一样，也没办法放在git仓库里，可以如下做</p>
<ul>
<li>在项目根目录里创建.mygithooks</li>
<li>在.mygithooks里创建pre-commit</li>
<li>编辑pre-commit    <code>npx eslint ./src</code></li>
<li>修改githooks的执行lujing  <code>git config core.hooksPath .mygithooks</code></li>
<li>给pre-commit赋予权限，<code>chmod +x .mygithooks/pre-commit</code></li>
</ul>
<h4 id="使用husky">使用husky</h4>
<ul>
<li>安装：<code>npm i husky -D</code></li>
<li>执行：<code>npx husky install</code></li>
<li>配置package.json,添加script脚本</li>
</ul>
<pre><code>scripts:{
    &quot;prepare&quot;:&quot;husky install&quot;
}
</code></pre>
<ul>
<li>在.husky文件下添加pre-commit</li>
<li>编辑pre-commit    <code>npx eslint ./src</code></li>
<li>给pre-commit赋予权限</li>
</ul>
<h2 id="32-模块与依赖">3.2 模块与依赖</h2>
<h3 id="321-模块解析">3.2.1 模块解析</h3>
<p>webpack通过Resolvers实现了模块之间的依赖和引用<br>
所引用的模块可以是来自应用程序的代码，也可以是第三方库。resolver帮助webpack从每个require/import语句中，找到需要引入到bundle中的代码模块。当打包模块时，webpack使用enhanced-resolve来解析文件路径。</p>
<h4 id="解析绝对路径">解析绝对路径</h4>
<h4 id="解析相对路径">解析相对路径</h4>
<h4 id="解析模块路径">解析模块路径</h4>
<h4 id="使用别名来优化">使用别名来优化</h4>
<p>在webpack.config.js下加入如下配置：</p>
<pre><code>const path = require('path')
resolve:{
    alias:{
        '@':path.resolve(__dirname,'./src')
    },
    extensions:['.json','.js','.vue']//配置加载模块的顺序
}
</code></pre>
<h3 id="322-外部扩展">3.2.2 外部扩展</h3>
<p>比如我们想引入jquery，那么在webpack.config.js中配置：</p>
<pre><code>externalsType:'script',
externals:{
    jquery:[//这个jquery就是import的名字
        '//这里写cdn链接'，
        '$'//表示script标签在浏览器上暴露的对象
    ]
}
</code></pre>
<h3 id="323-依赖图">3.2.3 依赖图</h3>
<p>每当一个文件依赖另一个文件时，webpack 会直接将文件视为存在依赖关系。这使 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把他们作为依赖提供给应用程序。当 webpack 开始工作时，它会根据我们写好的配置，从入口 (Entry) 开始，webpack 会递归的构建一个依赖关系图，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为输出文件。</p>
<ul>
<li>webpack-chart：webpack stats 可交互饼图；</li>
<li>webpack-visualizer：可视化并分析你的bundle，检查哪些模块占用空间，哪些可能使重复使用的；</li>
<li>webpack-bundle-analyzer：一个 plugin 和 CLI 工具，它将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式；</li>
<li>webpack bundle optimize helper：分析你的bundle并提供可操作的改进措施，减少 bundle 的大小；</li>
<li>bundle-stats：生成一个 bundle 报告 ( bundle大小、资源、模块 )，并比较不同构建之间的结果。</li>
</ul>
<h4 id="webpack-bundle-analyzer使用">webpack-bundle-analyzer使用</h4>
<ul>
<li>下载webpack-bundle-analyzer <code>npm i  webpack-bundle-analyzer -D</code></li>
<li>配置webpack.config.js</li>
</ul>
<pre><code>const {BundleAnalyzerPlugin} = require('webpack-bundle-analyzer')


module.exports={
	plugins:[
		new BundleAnalyzerPlugin()
	]
}
</code></pre>
<h2 id="33">3.3</h2>
<h3 id="331-postcss与css模块">3.3.1 PostCSS与CSS模块</h3>
<p><strong>PostCSS</strong> 是一个用javascript工具和插件转换css代码的工具。比如可以使用Autoprefixer插件自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮我们自动的为css规则添加前缀<br>
<strong>CSS模块</strong>能让你永远不用担心命名太大众化而造成的冲突，只要用最有意义的名字就行了</p>
<h4 id="postcss">PostCSS</h4>
<ul>
<li>安装：<code>npm i postcss-loader -D</code></li>
<li>修改配置文件</li>
</ul>
<pre><code>  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          'style-loader',
          'css-loader',
          'postcss-loader'
        ]
      }
    ]
  }
</code></pre>
<ul>
<li>安装插件：<code>npm i autoprefixer -D</code></li>
<li>项目根目录下创建postcss.config.js并编写如下配置</li>
</ul>
<pre><code>module.exports={
    plugins:[
        require('autoprefixer')
    ]
}
</code></pre>
<ul>
<li>在package.json添加如下配置</li>
</ul>
<pre><code>&quot;browserslist&quot;:[
    &quot;&gt;1%&quot;,
    &quot;last 2 versions&quot;
]
</code></pre>
<ul>
<li>安装插件：<code>npm i postcss-nested -D</code>,可以使用嵌套样式</li>
<li>编写postcss.config.js</li>
</ul>
<pre><code>module.exports={
    plugins:[
        require('autoprefixer'),
        require('postcss-nested')
    ]
}
</code></pre>
<h4 id="css模块">css模块</h4>
<pre><code>  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          'style-loader',
          {
              loader:'css-loader',
              options:{
                  modules:true
              }
          },
          'postcss-loader'
        ]
      }
    ]
  }
</code></pre>
<ul>
<li>
<p>在js中引入css时可以向模块化一样引入<code>import style from './app.css'</code></p>
</li>
<li>
<p>使用时直接用style.box,值是一个唯一的值，不用担心冲突</p>
</li>
<li>
<p>也可以部分开启css模块样式，全局样式加上.global前缀，如</p>
<ul>
<li>.global.css 普通模式，用 new RegExp(<code>^(?!.*\\.global).*\\.css</code>)</li>
<li>.css module模式，用 new RegExp(<code>^(.*\\.global).*\\.css</code>)</li>
</ul>
</li>
<li>
<p>在定义module时进行两种不同的正则匹配</p>
</li>
</ul>
<h3 id="332-web-workers">3.3.2 Web Workers</h3>
<p>Web Workers提供了js的后台处理线程的api，允许我们将复杂的、耗时的、单纯的js处理逻辑放在浏览器的后台线程中进行处理，让js线程不阻塞UI线程渲染。webpack5内置了打包WebWorker这个功能</p>
<ul>
<li>编写一个worker.js</li>
</ul>
<pre><code>self.onmessage=(message)=&gt;{
    self.postMessage({
        answer:1111
    })
}
</code></pre>
<ul>
<li>app.js里面编写如下代码</li>
</ul>
<pre><code>const worker= new Worker(new URL('./work.js',import.meta.url))
work.postMessage({
    question:'hi,那边的worker线程，请告诉我今天的幸运数字输多少？'
})

worker.onmessage=(message)=&gt;{
    console.log(message.data.answer)
}
</code></pre>
<h3 id="333-typescript">3.3.3 Typescript</h3>
<h4 id="安装-2">安装</h4>
<p><code>npm i typescript ts-loader -D</code></p>
<h4 id="配置-2">配置</h4>
<pre><code>module.exports={
    devtool:'inline-source-map',
    module:{
        rules:[
            {
                test:/\.ts$/,
                use:'ts-loader',
                exclude://node_modules
            }
        ]
    },
    resolve:{
        extensions:['.ts','.js']
    }
}
</code></pre>
<h4 id="创建ts配置文件">创建ts配置文件</h4>
<p>项目根目录下执行<code>npx tsc --init</code>,自动生成tsconfig.json<br>
修改配置文件,添加如下配置：</p>
<pre><code>&quot;rootDir&quot;:&quot;./src&quot;,
&quot;outDir&quot;:&quot;./dist&quot;
</code></pre>
<h2 id="34-tree-shaking">3.4 tree-shaking</h2>
<h3 id="341什么是tree-shaking">3.4.1什么是tree-shaking</h3>
<ul>
<li>把没有用的代码全部删掉</li>
<li>webpack不能百分百进行tree-shaking，有些模块导入了就会有严重的影响（有副作用）</li>
<li>所以具有副作用的文件不应该被tree-shaking,比如说样式文件虽然导入没有使用，但是依然会产生作用，所以不应该被tree-shaking</li>
<li>配置如下</li>
</ul>
<pre><code>optimization:{
    usedExports:true
}
</code></pre>
<h3 id="342-sideeffects">3.4.2 sideEffects</h3>
<p>可以在package.json里面设置副作用</p>
<pre><code>&quot;sideEffects&quot;:true//表示所有文件都有副作用，都不会被tree-shaking
&quot;sideEffects&quot;:false//表示所有文件都没有副作用，都会被tree-shaking
&quot;sideEffects&quot;:[&quot;*.css&quot;]//表示数组内所有文件都有副作用，都不会被tree-shaking
</code></pre>
<h2 id="35-渐进式网络应用程序pwa">3.5 渐进式网络应用程序（PWA）</h2>
<ul>
<li>最主要的时在离线情况下应用程序能够继续运行</li>
</ul>
<h3 id="351-使用http-server">3.5.1 使用http-server</h3>
<ul>
<li>安装:<code>npm i http-server -D</code></li>
<li>配置：</li>
</ul>
<pre><code>  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;http-server dist&quot;
  },
</code></pre>
<ul>
<li>运行：<code>npm run start</code></li>
</ul>
<h3 id="352-使用webpack-dev-server">3.5.2 使用webpack-dev-server</h3>
<ul>
<li>安装:<code>npm i webpack-dev-server -D</code></li>
<li>配置：</li>
</ul>
<pre><code>devServer：{

}
</code></pre>
<ul>
<li>运行：<code>npx webpack serve</code></li>
<li>webpack-dev-server执行是保存在内存中的，如果想要改变打包的结果需要重新打包，或者如下配置：</li>
</ul>
<pre><code>devServer：{
    devMiddleware:{
        writeToDisk:true
    }
}
</code></pre>
<h3 id="353-pwa">3.5.3 PWA</h3>
<ul>
<li>无论是http-server还是webpack-dev-server，当服务器停止后都无法访问页面</li>
<li>安装work-box来实现pwa：<code>npm i workbox-webpack-plugin -D</code></li>
<li>使用插件</li>
</ul>
<pre><code>const WorkboxPlugin = require('workbox-webpack-plugin')
plugins:[
    new WorkboxPlugin.GenerateSW({
        clientsClaim:true,
        skipWaiting:true
    })
]
</code></pre>
<ul>
<li>浏览器中也要做相应的配置</li>
</ul>
<pre><code>if('serviceWorker' in navigator){
	window.addEventListener('load',()=&gt;{
		navigator.serviceWorker.register('/service-worker.js')
			.then(registration=&gt;{
				console.log('SW 注册成功：',registration)
			})
			.catch(registrationError=&gt;{
				console.log('SW 注册失败：',registrationError)
			})
	})
}

</code></pre>
<ul>
<li>此时发现，即使服务器关闭也可以访问网页。主要是应用了缓存</li>
</ul>
<h2 id="36-shimming预制依赖">3.6 Shimming预制依赖</h2>
<h3 id="361-shimming用处">3.6.1 shimming用处</h3>
<ul>
<li>一些第三方库会创建一些需要导出的全局变量，这些不合规范的模块也就是shimming发挥作用的地方</li>
<li>当希望polyfills，也就是扩展浏览器能力能够支持更多用户时，只需要把polyfills提供给需要修补的用户，也就是实现按需加载</li>
</ul>
<h3 id="362-shimming预制全局变量">3.6.2 shimming预制全局变量</h3>
<ul>
<li>如果遇到下划线，把lodash的包提供给他</li>
</ul>
<pre><code>const webpack = require('webpack')
plugins:[
    new webpack.ProvidePlugin({
        _:'lodash'
    })
]
</code></pre>
<h3 id="363-细颗粒度的shimming">3.6.3 细颗粒度的shimming</h3>
<ul>
<li>在commonJS上下文中，this指向的是module.exports，而不是window。那么执行this.alert('ss')会报错。可以使用imports-loader来覆盖this的指向</li>
<li>安装：<code>npm i imports-loader -D</code></li>
<li>修改配置文件</li>
</ul>
<pre><code>module:{
    rules:[
        {
            test:require.resolve('./src/index.js'),
            use:'imports-loader?wrapper=window'
        }
    ]
}
</code></pre>
<h3 id="364-全局export">3.6.4 全局Export</h3>
<ul>
<li>安装：<code>npm i exports-loader -D</code></li>
<li>配置：</li>
</ul>
<pre><code>module:{
    rules:[
        {
            test:require.resolve('./src/globals.js'),
            use:'exports-loader?type=commonjs&amp;exports=file,multiple|helpers.parse|parse'
        }
    ]
}
</code></pre>
<ul>
<li>用途：global.js是外部的文件，一般情况下我们不知道他是如何导出的</li>
</ul>
<h3 id="365-加载polyfills">3.6.5 加载Polyfills</h3>
<ul>
<li>用处：可以进行<strong>优雅降级</strong></li>
<li>安装：<code>npm i --save @babel/polyfill</code></li>
<li>在对应的js中使用：<code>import @babel/polyfill</code></li>
</ul>
<h3 id="366-进一步优化polyfills">3.6.6 进一步优化Polyfills</h3>
<ul>
<li>不建议使用<code>import @babel/polyfill</code>。因为这样会在全局引入整个polyfill包。不但包体积大，而且还会污染全局变量</li>
<li>bable-preset-env通过browserslist来转译浏览器中不支持的特性。这个preset使用useBuiltIns选项，默认值是false，这种方式可以把全局导入的babel-polyfill改进为更细粒度的import格式</li>
<li>安装@babel/preset-env及i相关的包</li>
</ul>
<p><code>npm i babel-loader @babel/core @babel/preset-env -D</code><br>
<code>npm i core-js@23 -D</code></p>
<ul>
<li>修改配置文件</li>
</ul>
<pre><code>rules:[
    {
        test:/\.js$/,
        exclude:/node_modules/,
        use:{
            loader:'babel-loader',
            options:{
                presets:[
                    [
                        '@babel/preset-env',
                        {
                            targets:[
                                'last 1 version',
                                '&gt;1%'
                            ],
                            useBuiltIns:'usage',
                            corejs:3
                        }
                    ]
                ]
            }
        }
    }
]
</code></pre>
<h2 id="37-创建library">3.7 创建Library</h2>
<p>让代进行Library打包，因该这样配置</p>
<pre><code>output:{
    library:{
        name:'mylib',
        type:'window'//还可以是commonjs，module，umd
    }
}
</code></pre>
<p><strong>注意</strong></p>
<ul>
<li>es6模块化还处于试用阶段，所以需添加配置</li>
</ul>
<pre><code>experiments:{
    outputModule:true
}
</code></pre>
<ul>
<li>es6模块化不能设置name，引入时要解构赋值</li>
<li>umd的library可以支持scripts标签、commonjs和amd，其中使用commonjs时需要修改配置文件,且引用时需要解构赋值</li>
</ul>
<pre><code>output:{
    library:{
        name:'mylib',
        type:'window'//还可以是commonjs，module，umd
    },
    globalObject:'globalThis'
}
</code></pre>
<h2 id="38-模块联邦">3.8 模块联邦</h2>
<p>假如我们现在有三个应用，nav，home，search<br>
现在nav的webpack.config.js里面做如下配置</p>
<pre><code>const {ModuleDederationPlugin} = require('webpack').container
module.exports={
    plugins:[
        new ModuleDederationPlugin({
            //标识模块联邦的名字
            name:'nav',
            //使用这个模块联邦的应用
            filename:'remoteEntry.js',
            //引用其他应用暴露的组件
            remotes:{},
            //我们要暴露的
            exposes:{
                './Header':'./src/Header.js'
            },
            //共享的，单独打包
            shared:{}
        })
    ]
}
</code></pre>
<p>在home组件里面使用模块联邦</p>
<pre><code>const {ModuleDederationPlugin} = require('webpack').container
module.exports={
    plugins:[
        new ModuleDederationPlugin({
            //标识模块联邦的名字
            name:'nav',
            //使用这个模块联邦的应用
            filename:'remoteEntry.js',
            //引用其他应用暴露的组件
            remotes:{
                nav:'nav@http://localhost:3003/remoteEntry.js'
            },
            //我们要暴露的
            exposes:{},
            //共享的，单独打包
            shared:{}
        })
    ]
}
</code></pre>
<p>在index.js里面引入</p>
<pre><code>import('nav/Header').then((Header)=&gt;{
    const body = document.createElement('div')
    body.appendChild(Header.default())
})
</code></pre>
<h2 id="39-提升构建性能">3.9 提升构建性能</h2>
<h3 id="391-通用环境优化">3.9.1 通用环境优化</h3>
<ol>
<li>更新到最新版本（webpack，node，npm，yarn）</li>
<li>将loader应用于最小数量的必要模块</li>
<li>引导（bootstrap），每个额外的loader/plugin都有其启动时间，尽量少的使用工具</li>
<li>解析：
<ol>
<li>减少resolve.modules,resolve.extensions,resolve.mainFiles,resolve.description中条目数量，因为他们会增加文件系统调用次数</li>
<li>如果不使用symlinks，可以设置resolve.symlinks:false</li>
<li>如果使用自定义resolve plugin规则，并且没有指定context上下文，可以设置resolve.cacheWithContext:false</li>
</ol>
</li>
<li>小就是快，减少编译结果整体大学校，以提高构建性能。尽量保持chunk体积小。
<ol>
<li>使用数量更少/体积更小的library</li>
<li>在多页面应用程序中使用SplitChunksPlugin，并开启asunc模式</li>
<li>移除未引用代码</li>
<li>只编译当前正在开发的那些代码</li>
</ol>
</li>
<li>持久化缓存：在webpack配置中使用cache选项。使用package.json中的&quot;postinstall&quot;清除缓存目录。将cache类型设置为内存或者文件系统。memory选项很简单。它告诉webpack在内存中缓存，不允许额外的配置。</li>
<li>自定义plugin/loader时，要对他们进行分析，避免性能问题</li>
<li>progress plugin：删除progress plugin会缩短构建时间。但是不会缩短太多，请权衡利弊</li>
<li>dll：使用dllplugin为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管她增加了构建过程的复杂度</li>
<li>worker池：thread-loader可以将非常消耗资源的loader分流给一个worker pool</li>
</ol>
<h3 id="392-dll">3.9.2 dll</h3>
<ol>
<li>下载好第三方库后，使用 import 语法在 JS 文件中引入文件<br>
<code>import _ from 'jquery';</code></li>
<li>在根目录中创建 webpack.dll.config.js</li>
</ol>
<pre><code>const path = require('path');
const Webpack = require('webpack');

module.exports = {
  entry: {
    jquery: ['jquery'],
  },
  output: {
    // 输出文件名称
    filename: '[name].js',
    // 输出文件路径
    path: path.resolve(__dirname, '../dll'),
    // 导出库名称
    library: '[name]_[hash]',
  },
  plugins: [
    // 引入插件
    new Webpack.DllPlugin({
      // 对应导出的库名称
      name: '[name]_[hash]',
      // 生成 manifest 文件
      path: path.resolve(__dirname, '../dll/manifest.json'),
    }),
  ],
  mode: 'production',
}
</code></pre>
<ol start="3">
<li>在 package.json 中编辑</li>
</ol>
<pre><code>&quot;scripts&quot;: {
  &quot;dll&quot;: &quot;webpack --config ./webpack.dll.config.js&quot;
}
</code></pre>
<ol start="4">
<li>执行指令</li>
</ol>
<p><code>npm run dll</code><br>
5. 然后配置 webpack.config.js 文件</p>
<pre><code>const path = require('path')
const Webpack = require('webpack')

module.exports = {
  ...
  plugins: [
    // 告诉 webpack 哪些库布参与打包，以及使用的名称
    new Webpack.DllReferencePlugin({
      manifest: path.resolve(__dirname, 'dll/manifest.json')
    })
  ]
}
</code></pre>
<ol start="6">
<li>如需在页面中自动引用，需安装一个插件 add-asset-html-webpack-plugin，再在 webpack.config.js 文件中进行配置</li>
</ol>
<p><code>npm i add-asset-html-webpack-plugin -D</code></p>
<pre><code>const path = require('path')
const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')

module.exports = {
  ...
  plugins: [
    // 在html中自动引入
    new AddAssetHtmlWebpackPlugin({
      filepath: path.resolve(__dirname, 'dll/gsap.js'),
      publicPath: './'
    })
  ]
}
</code></pre>
<h3 id="393-worker-pool">3.9.3 worker pool</h3>
<ol>
<li>安装：<code>npm i babel-loader @babel/core @babel/preset-env -D</code></li>
<li>安装worker pool需要的依赖：<code>npm i thread-loader -D</code></li>
<li>配置</li>
</ol>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /(node_modules)/,
        use: [
            {
                loader: 'babel-loader',
                options: {
                    presets: ['@babel/preset-env']
                }
            },
            {
                loader:'thread-loader',
                options:{
                    workers:2
                }
            }
        ]
      }
    ]
  }
}
</code></pre>
<ol start="4">
<li>不要使用太多的worker，因为使用worker也有开销。进程间通信很耗资源</li>
</ol>
<h3 id="394-开发环境提升构建性能">3.9.4 开发环境提升构建性能</h3>
<ol>
<li>增量编译：使用wenpack的watch mode。</li>
<li>在内存中编译：比如说：webpack-dev-server,webpack-hot-middleware,webpack-dev-middleware</li>
<li>stats.toJson加速</li>
<li>Devtool：不同的devtool配置会导致性能差异。最佳选择eval-cheap-module-source-map</li>
<li>避免在生产环境才用到的工具</li>
<li>最小化entry chunk</li>
<li>避免额外的优化步骤，所以一般配置下面的选项</li>
</ol>
<pre><code>optimization:{
    removeAvailableModules:false,
    removeEmptyChunks:false,
    splitChunks:false
}
</code></pre>
<ol start="8">
<li>输出结果避免携带路径信息</li>
</ol>
<pre><code>output:{
    pathinfo:false
}
</code></pre>
<ol start="9">
<li>node.js版本问题。node.js v8.9.10-v9.11.1的Map和Set实现存在性能回退。webpack大量使用这些数据结构，因此这次回退也会影响编译时间</li>
<li>TypeScript Loader。为loader传入transpileOnly选项，以缩短使用ts-loader时的构建时间。使用此选项会关闭类型检查。如果要再次开启类型检查请使用ForkTsCheckerWebPackPlugin。使用此插件会将检查的过程移动到单独的线程。可以加快TypeScript的类型检查和ESLint插入的速度</li>
</ol>
<pre><code>use:[
    {
        loader:'ts-loader',
        options:{
            transpileOnly:true
        }
    }
]
</code></pre>
<h3 id="395-生产环境提升构建性能">3.9.5 生产环境提升构建性能</h3>
<ol>
<li>不用sourcemap</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DOMContentLoaded和onload]]></title>
        <id>https://star2399.github.io/post/domcontentloaded-he-onload/</id>
        <link href="https://star2399.github.io/post/domcontentloaded-he-onload/">
        </link>
        <updated>2022-09-29T10:31:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1js代码与body标签的位置关系">1.JS代码与body标签的位置关系</h1>
<p>如果js代码写在body标签前面，而且没用其他事件而直接获取dom的话是无法获取的。而js代码写在body标签的后面（里面的最后也可以）就可以获取dom。</p>
<p>实际上如果了解浏览器解析HTML规则就很清楚原因了，浏览器解析HTML由上往下依次执行，如果遇到<code>&lt;script&gt;</code>会阻塞解析，先执行该JS脚本（如果是外部JS文件还要先加载），执行结束后再接着往下解析，所以上面获取不到dom的原因是当时JS代码执行时页面DOM树尚未构建完成。具体分析往下看。</p>
<h1 id="2script标签的defer和async">2.script标签的defer和async</h1>
<p>从上面知道，浏览器解析HTML遇到script标签会阻塞。上面举例的JS代码都是内嵌在HTML中的，这样再解析到script时直接执行就行。但如果是引入外部JS文件的话会有一点不同，要先加载该JS文件，然后执行，然后在往下解析HTML。但script标签上还有两个常见属性defer和async</p>
<h2 id="21-一般情况script-srcxxxjs">2.1 一般情况<script src="xxx.js"></h2>
<p>当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档</p>
<h2 id="22-defer-script-defer-srcxxxjs">2.2 defer <script defer src="xxx.js"></h2>
<p>浏览器遇到 script 标签时，文档的解析不会停止，JS文件的加载与文档解析并行（异步），待到文档解析DOM构建完成，脚本才会执行（在DOMContentLoaded事件触发之前）。</p>
<h2 id="23-async-script-async-srcxxxjs">2.3 async <script async src="xxx.js"></h2>
<p>当浏览器遇到 script 标签时，文档的解析不会停止，JS文件的加载与文档解析并行（异步），脚本下载完成后开始执行脚本，脚本执行时文档会停止解析。<br>
<img src="https://star2399.github.io/post-images/1664447685461.jpg" alt="" loading="lazy"></p>
<h2 id="24-总结defer和async的区别">2.4 总结defer和async的区别：</h2>
<ul>
<li>加载时是一样的，相对于HTML解析是异步的。</li>
<li>不同的是执行时机，async在代码加载完之后会马上执行，并且执行时会阻塞HTML解析。而defer则要等到文档解析DOM构建完成，DOMContentLoaded事件触发之前执行。</li>
<li>async执行时机不确定性，要注意使用场景。</li>
</ul>
<h1 id="3domcontentloaded和windowonload">3.DOMContentLoaded和window.onload</h1>
<h2 id="31-domcontentloaded">3.1 DomContentLoaded</h2>
<ul>
<li>MDN解释：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。</li>
<li>在DOMContentLoaded后面引入样式表，DOMContentLoaded可能无法获取样式表里的样式，因为此时HTML解析完成，DOM树构建完成，但外部css文件可能还没加载完成。</li>
</ul>
<h2 id="32-windowonload">3.2 window.onload</h2>
<p>此时HTML文档解析完成，其他依赖资源（css）也全部加载完成。</p>
<h1 id="4总结">4.总结</h1>
<h2 id="html文档加载步骤">HTML文档加载步骤：</h2>
<ol>
<li>由上往下解析HTML结构。</li>
<li>遇到src属性则发起请求加载资源，只有script会阻塞HTML解析，其他（css、img等）都不会影响HTML解析。</li>
<li>script资源加载完，执行JS脚本。</li>
<li>DOM树构建完成，触发DOMContentLoaded</li>
<li>其他css、img、iframe等资源如果还未加载完成继续加载。</li>
<li>页面加载完毕，触发window.onload</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS事件模型]]></title>
        <id>https://star2399.github.io/post/js-shi-jian-mo-xing/</id>
        <link href="https://star2399.github.io/post/js-shi-jian-mo-xing/">
        </link>
        <updated>2022-09-25T12:28:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-事件与事件流">一、事件与事件流</h1>
<p>事件是与浏览器或文档交互的瞬间，如点击按钮，填写表格等，它是JS与HTML之间交互的桥梁。<br>
DOM是树形结构，如果同时给父子节点都绑定事件时，当触发子节点的时候，这两个事件的发生顺序如何决定?这就涉及到事件流的概念，它描述的是页面中接受事件的顺序。</p>
<p>事件流有两种:</p>
<ul>
<li>事件冒泡(Event Capturing): 是一种从下往上的传播方式。事件最开始由最具体的元素(文档中嵌套层次最深的那个节点接受, 也就是DOM最低层的子节点), 然后逐渐向上传播到最不具体的那个节点，也就是DOM中最高层的父节点。</li>
<li>事件捕获(Event Bubbling): 与事件冒泡相反。事件最开始由不太具体的节点最早接受事件, 而最具体的节点最后接受事件。<br>
顺序：<br>
捕获阶段-目标阶段-冒泡阶段<br>
同时绑定事件捕获和事件冒泡，会先执行事件捕获。</li>
</ul>
<h1 id="二-事件模型">二、事件模型</h1>
<ul>
<li>DOM0就是直接通过 onclick写在html里面的事件;</li>
<li>DOM2是通过addEventListener绑定的事件, 还有IE下的DOM2事件通过attachEvent绑定;</li>
<li>DOM3是一些新的事件</li>
</ul>
<h2 id="dom0级模型">DOM0级模型</h2>
<p>又称为原始事件模型，在该模型中，<strong>事件不会传播，即没有事件流的概念</strong>。事件绑定监听函数比较简单, 有两种方式:</p>
<ul>
<li>
<ol>
<li>HTML代码中直接绑定:<br>
<code>&lt;input type=&quot;button&quot; onclick=&quot;fun()&quot;&gt;</code></li>
</ol>
</li>
<li>
<ol start="2">
<li>通过JS代码指定属性值:<br>
<code>var btn = document.getElementById('.btn'); btn.onclick = fun;</code></li>
</ol>
</li>
</ul>
<p>移除监听函数：</p>
<p><code>btn.onclick = null;</code><br>
这种方式所有浏览器都兼容，但是逻辑与显示并没有分离。</p>
<h2 id="ie事件模型">IE事件模型</h2>
<p>IE事件模型共有两个过程:</p>
<ul>
<li>
<p>事件处理阶段(target phase)。事件到达目标元素, 触发目标元素的监听函数。</p>
</li>
<li>
<p>事件冒泡阶段(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</p>
</li>
</ul>
<p>事件绑定监听函数的方式如下:<br>
<code>attachEvent(eventType, handler)</code></p>
<p>事件移除监听函数的方式如下:<br>
<code>detachEvent(eventType, handler)</code></p>
<p>参数说明:</p>
<ul>
<li>
<p>eventType指定事件类型(注意加on)</p>
</li>
<li>
<p>handler是事件处理函数</p>
</li>
</ul>
<h2 id="dom2级模型">DOM2级模型</h2>
<p>属于W3C标准模型，现代浏览器(除IE6-8之外的浏览器)都支持该模型。在该事件模型中，一次事件共有三个过程:</p>
<ul>
<li>
<p>事件捕获阶段(capturing phase)。事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</p>
</li>
<li>
<p>事件处理阶段(target phase)。事件到达目标元素, 触发目标元素的监听函数。</p>
</li>
<li>
<p>事件冒泡阶段(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</p>
</li>
</ul>
<p>事件绑定监听函数的方式如下:</p>
<p><code>addEventListener(eventType, handler, useCapture)</code></p>
<p>事件移除监听函数的方式如下:</p>
<p><code>removeEventListener(eventType, handler, useCapture)</code></p>
<h2 id="dom3级事件处理方式">DOM3级事件处理方式</h2>
<p>DOM浏览器中可能发生的事件有很多种不同事件类型具有不同的信息DOM3级事件规定了一下几种事件</p>
<ul>
<li>UI事件当用户与页面上的元素交互时触发</li>
<li>焦点事件当元素获得或者失去焦点时触发</li>
<li>鼠标事件当用户通过鼠标在页面上执行操作时触发</li>
<li>滚轮事件当使用鼠标滚轮或类似设备时触发</li>
<li>文本事件当在文档中输入文本时触发</li>
<li>键盘事件当用户通过键盘在页面上执行操作时触发</li>
<li>合成事件当为IMEInput Method Editor输入法编辑器输入字符时触发</li>
<li>变动事件当底层Dom结构发生变化时触发</li>
</ul>
<p>DOM3级事件模块在DOM2级事件的基础上重新定义了这些事件也添加了一些新事件。包括IE9在内的主流浏览器都支持DOM2级事件IE9也支持DOM3级事件。</p>
<h1 id="三-事件对象">三、事件对象</h1>
<p>当一个事件被触发时，会创建一个事件对象(Event Object), 这个对象里面包含了与该事件相关的属性或者方法。该对象会作为第一个参数传递给监听函数。</p>
<p>DOM事件模型中的事件对象常用属性:</p>
<ul>
<li>type用于获取事件类型</li>
<li>target获取事件目标</li>
<li>stopPropagation()阻止事件冒泡</li>
<li>preventDefault()阻止事件默认行为</li>
</ul>
<p>IE事件模型中的事件对象常用属性:</p>
<ul>
<li>type用于获取事件类型</li>
<li>srcElement获取事件目标</li>
<li>cancelBubble阻止事件冒泡</li>
<li>returnValue阻止事件默认行为</li>
</ul>
<h1 id="四-事件绑定与解除">四、事件绑定与解除</h1>
<h2 id="41-绑定">4.1 绑定</h2>
<h3 id="411-对象on事件名字事件处理函数">4.1.1 对象.on事件名字=事件处理函数</h3>
<p>缺点：如果绑定多个事件，前面的事件会被后面的事件覆盖</p>
<pre><code>document.getElementById(&quot;btn&quot;).onclick = function () {
        console.log(&quot;第一&quot;);
    };

</code></pre>
<h3 id="412-对象addeventlistener">4.1.2 对象.addEventListener</h3>
<p>优点：可以绑定多个事件</p>
<p>缺点：谷歌和火狐支持,IE8不支持</p>
<pre><code>document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;, function () {
        console.log(&quot;第一&quot;);
    }, false);
    //false冒泡阶段(默认),true捕获阶段

</code></pre>
<h3 id="413-对象attachevent">4.1.3 对象.attachEvent</h3>
<p>优点：可以绑定多个事件</p>
<p>缺点：谷歌和火狐不支持，IE8支持</p>
<pre><code>document.getElementById(&quot;btn&quot;).attachEvent(&quot;onclik&quot;, function () {
        console.log(&quot;第一&quot;);
    });

</code></pre>
<h2 id="42-解除绑定">4.2 解除绑定</h2>
<h3 id="421-对象on事件名字null">4.2.1 对象.on事件名字=null;</h3>
<h3 id="422-对象removeeventlistener">4.2.2 对象.removeEventListener</h3>
<h3 id="423-对象detachevent">4.2.3 对象.detachEvent</h3>
<h1 id="五-event-wrapper">五、Event Wrapper</h1>
<p>由于事件模型的差异以及Event对象的不同，为了达到兼容各个浏览器的目的，我们可以增加一个Event Wrapper, 它对各个浏览器应当提供一致的事件操作接口。</p>
<pre><code>var eventUtils={
     // 添加句柄
     addHandler:function(element,type,handler){
       if(element.addEventListener){
         element.addEventListener(type,handler,false);
       }else if(element.attachEvent){
         element.attachEvent('on'+type,handler);
       }else{
         element['on'+type]=handler;
       }
     },
     // 删除句柄
     removeHandler:function(element,type,handler){
       if(element.removeEventListener){
         element.removeEventListener(type,handler,false);
       }else if(element.detachEvent){
         element.detachEvent('on'+type,handler);
       }else{
         element['on'+type]=null;
       }
     },
    //获取事件对象
    //IE模型中event是一个全局唯一的对象绑定在window对象上
    getEvent:function(event){
       return event?event:window.event;
    },
    //获取类型
    getType:function(event){
     return event.type;
    },
    getElement:function(event){
     return event.target || event.srcElement;
    },
    //阻止默认事件
    preventDefault:function(event){
     if(event.preventDefault){
      event.preventDefault();
     }else{
      event.returnValue=false;
     }
    },
    //阻止冒泡
   stopPropagation:function(event){
   if(event.stopPropagation){
     event.stopPropagation();
   }else{
     event.cancelBubble=true;
    }
   }
  }

</code></pre>
<h1 id="六-自定义事件">六、自定义事件</h1>
<p>JS中已经内置了很多事件，如click, mouseover等等，但是内置事件毕竟有限，有时候我们想自己定义一些事件，例如三连击，threeclick。如何实现自定义事件呢？</p>
<h2 id="1首先要创建一个事件-可以使用以下方式">1.首先要创建一个事件。可以使用以下方式:</h2>
<p><code>var event = new Event('threeclick', {&quot;bubbles&quot;:true, &quot;cancelable&quot;:false});</code></p>
<ul>
<li>bubbles表示该事件是否冒泡。</li>
<li>cancelable表示该事件能否被取消。</li>
</ul>
<h2 id="2然后我们需要为事件注册监听函数">2.然后我们需要为事件注册监听函数:</h2>
<p><code>target.addEventListener('threeclick', hello, false);</code></p>
<h2 id="3最后我们要在合适的时机触发该事件我们可以使用dispatchevent函数">3.最后我们要在合适的时机触发该事件，我们可以使用dispatchEvent函数。</h2>
<p>该方法在当前节点触发指定事件，从而触发监听函数执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault(), 则返回false, 否则返回true。</p>
<p><code>target.dispatchEvent(event);</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事件捕获、事件冒泡、事件委托]]></title>
        <id>https://star2399.github.io/post/shi-jian-bu-huo-shi-jian-mou-pao-shi-jian-wei-tuo/</id>
        <link href="https://star2399.github.io/post/shi-jian-bu-huo-shi-jian-mou-pao-shi-jian-wei-tuo/">
        </link>
        <updated>2022-09-25T11:58:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-事件捕获和冒泡">一、事件捕获和冒泡</h1>
<h2 id="11-事件冒泡">1.1 事件冒泡</h2>
<blockquote>
<p>在一个对象上触发某类事件（比如单击onclick事件），这个事件会向这个对象的父级对象传播，从里到外。父级对象所有同类事件都将被激活，或者它到达了对象层次的最顶层，即document对象<br>
<img src="https://star2399.github.io/post-images/1664107313545.png" alt="" loading="lazy"></p>
</blockquote>
<h2 id="12-事件捕获">1.2 事件捕获</h2>
<blockquote>
<p>和事件冒泡相反，事件是从最外层向最内层传播，直到到达最具体的元素上<br>
<img src="https://star2399.github.io/post-images/1664107464268.png" alt="" loading="lazy"></p>
</blockquote>
<h1 id="二-eventtargetaddeventlistener">二、EventTarget.addEventListener()</h1>
<blockquote>
<p>EventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。事件目标可以是一个文档上的元素 Element、Document 和 Window，也可以是任何支持事件的对象（比如 XMLHttpRequest）。</p>
</blockquote>
<h2 id="21-推荐使用-addeventlistener-来注册一个事件监听器理由如下">2.1 推荐使用 addEventListener() 来注册一个事件监听器，理由如下</h2>
<ul>
<li>它允许为一个事件添加多个监听器</li>
<li>相比于 onXYZ 属性绑定来说，它提供了一种更精细的手段来控制 listener 的触发阶段</li>
<li>它对任何事件都有效，而不仅仅是 HTML 或 SVG 元素。</li>
</ul>
<h2 id="22-工作原理">2.2 工作原理</h2>
<ul>
<li>addEventListener() 的工作原理是将实现 EventListener 的函数或对象添加到调用它的 EventTarget 上的指定事件类型的事件侦听器列表中。如果要绑定的函数或对象已经被添加到列表中，该函数或对象不会被再次添加。</li>
</ul>
<h2 id="23语法">2.3语法</h2>
<pre><code>addEventListener(type, listener);
addEventListener(type, listener, options);
addEventListener(type, listener, useCapture);
</code></pre>
<h2 id="24-参数">2.4 参数</h2>
<ul>
<li>type
<ul>
<li>表示监听事件类型的大小写敏感的字符串。</li>
</ul>
</li>
<li>listener
<ul>
<li>当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数。有关回调本身的详细信息，请参阅事件监听回调</li>
</ul>
</li>
<li>options （可选）
<ul>
<li>一个指定有关 listener 属性的可选参数对象。可用的选项如下：
<ul>
<li>capture（可选）
<ul>
<li>一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</li>
</ul>
</li>
<li>once（可选）
<ul>
<li>一个布尔值，表示 listener 在添加之后最多只调用一次。如果为 true，listener 会在其被调用之后自动移除。</li>
</ul>
</li>
<li>passive（可选）
<ul>
<li>一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告</li>
</ul>
</li>
<li>signal（可选）
<ul>
<li>AbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>useCapture
<ul>
<li>指定是冒泡阶段触发还是捕获阶段触发，为false表示冒泡阶段触发。默认为false。</li>
</ul>
</li>
</ul>
<h1 id="三-事件捕获和冒泡的实行顺序">三、事件捕获和冒泡的实行顺序</h1>
<ol>
<li>事件捕获过程： 当我们点击 TEXT时，首先时window-&gt; document -&gt; body -&gt; div -&gt; text,这个过程称为事件捕获,W3C浏览器的标准执行流程</li>
<li>事件冒泡过程:text -&gt; div -&gt; body -&gt; document -&gt; window,这个过程称为事件冒泡.IE浏览器只支持冒泡,不支持捕获,W3C 浏览器先执行捕获,后执行冒泡</li>
<li>对于触发的元素来说，捕获和冒泡的执行顺序取决于代码的书写顺序，谁在前面执行谁<br>
<img src="https://star2399.github.io/post-images/1664107525257.png" alt="" loading="lazy"></li>
</ol>
<h1 id="四-如何阻止事件冒泡">四、如何阻止事件冒泡</h1>
<h2 id="41-方式一">4.1 方式一</h2>
<p>event.stopPropagation( )</p>
<h2 id="42-方式二">4.2 方式二</h2>
<p>return false;</p>
<h2 id="43-区别">4.3 区别</h2>
<p>return false 不仅阻止了事件往上冒泡，而且阻止了事件本身。event.stopPropagation() 则只阻止事件往上冒泡，不阻止事件本身。</p>
<h1 id="五-事件委托">五、事件委托</h1>
<blockquote>
<p>其实是利用事件冒泡，让上级元素来处理，这样就避免了给每个元素添加事件处理器</p>
</blockquote>
<h2 id="优点">优点</h2>
<ol>
<li>减少事件注册,节省内存</li>
<li>简化了dom节点更新时,相应事件的更新</li>
<li>不用在新添加的li上绑定click事件</li>
<li>当删除某个li时,不用移解绑上面的click事件</li>
</ol>
<h2 id="缺点">缺点</h2>
<ol>
<li>事件委托基于冒泡,对于不冒泡的事件不支持</li>
<li>层级过多,冒泡过程中,可能会被阻止掉.</li>
<li>理论上委托会导致浏览器频繁调用处理函数,虽然很可能不需要处理,所以建议就近委托</li>
<li>把所有事件都用代理就可能会出来事件误判,比如,在document 中 代理了所有 button的click事件,另外的人在引用该js时,可能不知道,造成单击button触发了两个click事件</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Content-Type 详解]]></title>
        <id>https://star2399.github.io/post/content-type-xiang-jie/</id>
        <link href="https://star2399.github.io/post/content-type-xiang-jie/">
        </link>
        <updated>2022-09-25T07:34:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-content-type">一、Content-Type</h1>
<p>Content-Type（MediaType），即是Internet Media Type，互联网媒体类型，也叫做MIME类型。在互联网中有成百上千中不同的数据类型，HTTP在传输数据对象时会为他们打上称为MIME的数据格式标签，用于区分数据类型。最初MIME是用于电子邮件系统的，后来HTTP也采用了这一方案。</p>
<p>在HTTP协议消息头中，使用Content-Type来表示请求和响应中的媒体类型信息。它用来告诉服务端如何处理请求的数据，以及告诉客户端（一般是浏览器）如何解析响应的数据，比如显示图片，解析并展示html等等。</p>
<h2 id="content-type的格式">Content-Type的格式</h2>
<p>Content-Type：type/subtype ;parameter</p>
<ul>
<li>type：主类型，任意的字符串，如text，如果是*号代表所有；</li>
<li>subtype：子类型，任意的字符串，如html，如果是*号代表所有，用“/”与主类型隔开；</li>
<li>parameter：可选参数，如charset，boundary等。</li>
</ul>
<h1 id="二-常见content-type">二、常见Content-Type</h1>
<ul>
<li>HTML文档标记：text/html;</li>
<li>普通ASCII文档标记：text/html;</li>
<li>JPEG图片标记：image/jpeg;</li>
<li>GIF图片标记：image/gif;</li>
<li>js文档标记：application/javascript;</li>
<li>xml文件标记：application/xml;</li>
</ul>
<h2 id="applicationx-www-form-urlencoded">application/x-www-form-urlencoded</h2>
<p>HTTP会将请求参数用key1=val1&amp;key2=val2的方式进行组织，并放到请求实体里面，注意如果是中文或特殊字符如&quot;/&quot;、&quot;,&quot;、“:&quot; 等会自动进行URL转码。不支持文件，一般用于表单提交。</p>
<h2 id="multipartform-data">multipart/form-data</h2>
<p>与application/x-www-form-urlencoded不同，这是一个多部分多媒体类型。首先生成了一个 boundary 用于分割不同的字段，在请求实体里每个参数以------boundary开始，然后是附加信息和参数名，然后是空行，最后是参数内容。多个参数将会有多个boundary块。如果参数是文件会有特别的文件域。最后以------boundary–为结束标识。multipart/form-data支持文件上传的格式，一般需要上传文件的表单则用该类型。<br>
<img src="https://star2399.github.io/post-images/1664091894478.png" alt="" loading="lazy"></p>
<h2 id="applicationjson">application/json</h2>
<p>JSON 是一种轻量级的数据格式，以“键-值”对的方式组织的数据。这个使用这个类型，需要参数本身就是json格式的数据，参数会被直接放到请求实体里，不进行任何处理。服务端/客户端会按json格式解析数据（约定好的情况下）。</p>
<h2 id="applicationxml-和-textxml">application/xml 和 text/xml</h2>
<p>与application/json类似，这里用的是xml格式的数据，text/xml的话，将忽略xml数据里的编码格式</p>
<h1 id="三-content-type的使用">三、Content-Type的使用</h1>
<h2 id="request">request</h2>
<ul>
<li>如果是一个restful接口（json格式），一般将Content-Type设置为application/json; charset=UTF-8；</li>
<li>如果是文件上传，一般Content-Type设置为multipart/form-data</li>
<li>如果普通表单提交，一般Content-Type设置为application/x-www-form-urlencoded</li>
</ul>
<h2 id="response">response</h2>
<ul>
<li>一般情况下不需要显示设置；</li>
<li>如果是文件导出，Content-Type 设置为 multipart/form-data，并且添加一个Content-Disposition设置为attachment;fileName=文件.后缀。<br>
注：Content-Disposition是Content-Type的扩展，告诉浏览器弹窗下载框，而不是直接在浏览器里展示文件。因为一般浏览器对于它能够处理的文件类型，如txt，pdf 等，它都是直接打开展示，而不是弹窗下载框。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP状态码]]></title>
        <id>https://star2399.github.io/post/http-zhuang-tai-ma/</id>
        <link href="https://star2399.github.io/post/http-zhuang-tai-ma/">
        </link>
        <updated>2022-09-21T10:48:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-是什么">一、是什么</h1>
<p>HTTP状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的3位数字代码</p>
<p>它由 RFC 2616规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774与 RFC 4918等规范扩展</p>
<p>简单来讲，http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态</p>
<h1 id="二-分类">二、分类</h1>
<p>状态码第一位数字决定了不同的响应状态，有如下：</p>
<pre><code>1 表示消息
2 表示成功
3 表示重定向
4 表示请求错误
5 表示服务器错误
</code></pre>
<h2 id="1xx">1xx</h2>
<p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p>
<p>常见的有：</p>
<pre><code>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级
</code></pre>
<h2 id="2xx">2xx</h2>
<p>代表请求已成功被服务器接收、理解、并接受</p>
<p>常见的有：</p>
<pre><code>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回

201（已创建）：请求成功并且服务器创建了新的资源

202（已创建）：服务器已经接收请求，但尚未处理

203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源

204（无内容）：服务器成功处理请求，但没有返回任何内容

205（重置内容）：服务器成功处理请求，但没有返回任何内容

206（部分内容）：服务器成功处理了部分请求
</code></pre>
<h2 id="3xx">3xx</h2>
<p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p>
<p>常见的有：</p>
<pre><code>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择

301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置

302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码

305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理

307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
</code></pre>
<h2 id="4xx">4xx</h2>
<p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p>
<p>常见的有：</p>
<pre><code>400（错误请求）： 服务器不理解请求的语法
401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
403（禁止）： 服务器拒绝请求
404（未找到）： 服务器找不到请求的网页
405（方法禁用）： 禁用请求中指定的方法
406（不接受）： 无法使用请求的内容特性响应请求的网页
407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
408（请求超时）： 服务器等候请求时发生超时
</code></pre>
<h2 id="5xx">5xx</h2>
<p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p>
<p>常见的有：</p>
<pre><code>500（服务器内部错误）：服务器遇到错误，无法完成请求
501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本
</code></pre>
<h1 id="三-适用场景">三、适用场景</h1>
<pre><code>100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输

206：一般用来做断点续传，或者是视频文件等大文件的加载

301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名

302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面

304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分

400：参数有误，请求无法被服务器识别

403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回

404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时

503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503

504：网关超时
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object.getOwnPropertyDescriptors()]]></title>
        <id>https://star2399.github.io/post/objectgetownpropertydescriptors/</id>
        <link href="https://star2399.github.io/post/objectgetownpropertydescriptors/">
        </link>
        <updated>2022-09-21T06:41:09.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ES5 的 Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。</li>
<li>Object.getOwnPropertyDescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</li>
</ul>
<h1 id="引入的目的">引入的目的</h1>
<blockquote>
<p>主要是为了解决 Object.assign()无法正确拷贝 get属性和 set属性的问题</p>
</blockquote>
<pre><code>const source = {
  set foo(value) {
    console.log(value);
  }
};

const target1 = {};
Object.assign(target1, source);//输出{foo:undefined}
</code></pre>
<p>上面代码中， source对象的 foo属性的值是一个赋值函数， Object.assign方法将这个属性拷贝给 target1对象，结果该属性的值变成了 undefined。这是因为 Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。<br>
这时， Object.getOwnPropertyDescriptors()方法配合 Object.defineProperties()方法，就可以实现正确拷贝。</p>
<pre><code>const source = {
  set foo(value) {
    console.log(value);
  }
};

const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, 'foo')
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://star2399.github.io/post-images/1663742683823.png" alt="" loading="lazy"></figure>
<h1 id="配合objectcreate">配合Object.create()</h1>
<ul>
<li>Object.getOwnPropertyDescriptors()方法的另一个用处，是配合 Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。</li>
</ul>
<pre><code>const clone = Object.create(Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj));

const shallowClone = (obj) =&gt; Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</code></pre>
<h1 id="实现继承另一个对象">实现继承另一个对象</h1>
<ul>
<li>另外， Object.getOwnPropertyDescriptors()方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</li>
</ul>
<pre><code>const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object.assign()]]></title>
        <id>https://star2399.github.io/post/objectassign/</id>
        <link href="https://star2399.github.io/post/objectassign/">
        </link>
        <updated>2022-09-21T06:10:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-基本用法">一、基本用法</h1>
<p>Object.assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<pre><code>const target = { a: 1 }

const source1 = { b: 2 }
const source2 = { c: 3 }

Object.assign(target, source1, source2)
target // {a:1, b:2, c:3}
</code></pre>
<ul>
<li><strong>Object.assign() 方法的第一个参数是目标对象，后面的参数都是源对象。</strong></li>
<li><strong>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</strong></li>
</ul>
<pre><code>const target = { a: 1, b: 1 }

const source1 = { b: 2, c: 2 }
const source2 = { c: 3 }

Object.assign(target, source1, source2)
target // {a:1, b:2, c:3}
</code></pre>
<h2 id="1如果只有一个参数-objectassign会直接返回该参数">1.如果只有一个参数， Object.assign()会直接返回该参数。</h2>
<pre><code>const obj = {a: 1};
Object.assign(obj) === obj // true
</code></pre>
<h2 id="2如果该参数不是对象则会先转成对象然后返回">2.如果该参数不是对象，则会先转成对象，然后返回</h2>
<pre><code>typeof Object.assign(2)
//'object'
</code></pre>
<h2 id="3如果参数是undefined或null由于-undefined和-null无法转成对象会报错">3.如果参数是undefined或null，由于 undefined和 null无法转成对象，会报错</h2>
<pre><code>Object.assign(undefined)
Object.assign(null)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://star2399.github.io/post-images/1663740934377.png" alt="" loading="lazy"></figure>
<h2 id="4非对象参数出现在源对象的位置">4.非对象参数出现在源对象的位置</h2>
<ul>
<li>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先， 这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果 undefined和 null不在首参数，就不会报错。</li>
</ul>
<pre><code>let obj = {a: 1};
Object.assign(obj, undefined) === obj
Object.assign(obj, null) === obj
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://star2399.github.io/post-images/1663740998042.png" alt="" loading="lazy"></figure>
<ul>
<li>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字 符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</li>
</ul>
<h3 id="原因如下">原因如下</h3>
<pre><code>Object(true) // {[[PrimitiveValue]]: true}
Object(10)  //  {[[PrimitiveValue]]: 10}
Object('abc') // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://star2399.github.io/post-images/1663741074067.png" alt="" loading="lazy"></figure>
<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到 它们的原始值都在包装对象的内部属性 [[PrimitiveValue]] 上面，这个属性是不会被 Object.assign()拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<h2 id="5objectassign拷贝的属性是有限制的-只拷贝源对象的自身属性不拷贝继承属性也不拷贝不可枚举的属性-enumerable-false">5.Object.assign()拷贝的属性是有限制的， 只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（ enumerable: false）。</h2>
<h1 id="二-注意点">二、注意点</h1>
<h2 id="1objectassign-浅拷贝">1.Object.assign() 浅拷贝</h2>
<ul>
<li>Object.assign()方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</li>
</ul>
<h2 id="2替换同名属性">2.替换同名属性</h2>
<ul>
<li>对于这种嵌套的对象，一旦遇到同名属性， Object.assign()的处理方法是替换，而不是添加。</li>
</ul>
<h2 id="3处理数组时会把数组视为对象">3.处理数组时会把数组视为对象</h2>
<ul>
<li>Object.assign()可以用来处理数组，但是会把数组视为对象。</li>
</ul>
<pre><code>Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
</code></pre>
<p>上面代码中， Object.assign()把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性 4覆盖了目标数组的 0 号属性 1。</p>
<h2 id="4取值函数求值后再复制">4.取值函数求值后再复制</h2>
<ul>
<li>Object.assign()只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</li>
</ul>
<pre><code>const source = {
  get foo() { return 1 }
};
const target = {};

Object.assign(target, source)
//{foo:1}
</code></pre>
<p>上面代码中， source对象的 foo属性是一个取值函数， Object.assign()不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<h1 id="三-常见用途">三、常见用途</h1>
<h2 id="1为对象添加属性">（1）为对象添加属性</h2>
<h2 id="2为对象添加方法">（2）为对象添加方法</h2>
<h2 id="3克隆对象">（3）克隆对象</h2>
<h2 id="4合并多个对象">（4）合并多个对象</h2>
<h2 id="5为属性指定默认值">（5）为属性指定默认值</h2>
<pre><code>const DEFAULTS = {
  logLevel: 0,
  outputFormat: 'html'
}

function processContent(options) {
  options = Object.assign({}, DEFAULTS, options)
  console.log(options)
  // ...

}
</code></pre>
<p>上面代码中， DEFAULTS对象是默认值， options对象是用户提供的参数。 Object.assign()方法将 DEFAULTS和 options合并成一个新对象，如果两者有同名属性，则 options的属性值会覆盖 DEFAULTS的属性值。</p>
]]></content>
    </entry>
</feed>
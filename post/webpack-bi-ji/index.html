<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>WebPack笔记 | Star的个人博客</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://star2399.github.io/favicon.ico?v=1665043922722">
<link rel="stylesheet" href="https://star2399.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一、引入
1.1 为什么需要webpack

一个html要引入太多js
使用一个js引入其他多个js时会存在如下问题：


作用域问题
文件太大
可读性差
可维护性弱

1.2 如何解决作用域问题

grunt和gulp使用立即调用函数表..." />
    <meta name="keywords" content="Webpack" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://star2399.github.io">
        <img src="https://star2399.github.io/images/avatar.png?v=1665043922722" class="site-logo">
        <h1 class="site-title">Star的个人博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://star2399.github.io/post/shou-ye" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://star2399.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">WebPack笔记</h2>
            <div class="post-date">2022-10-02</div>
            
            <div class="post-content" v-pre>
              <h1 id="一-引入">一、引入</h1>
<h2 id="11-为什么需要webpack">1.1 为什么需要webpack</h2>
<ul>
<li>一个html要引入太多js</li>
<li>使用一个js引入其他多个js时会存在如下问题：</li>
</ul>
<ol>
<li>作用域问题</li>
<li>文件太大</li>
<li>可读性差</li>
<li>可维护性弱</li>
</ol>
<h2 id="12-如何解决作用域问题">1.2 如何解决作用域问题</h2>
<ul>
<li>grunt和gulp使用立即调用函数表达式（IIFE）来解决</li>
</ul>
<pre><code>(function (){
	var name=&quot;ss&quot;
})()
console.log(name)//无法打印

var exportname=(function (){
	var name=&quot;ss&quot;
	return name
})()//可以打印
console.log(exportname)

</code></pre>
<h2 id="13-如何解决代码拆分">1.3 如何解决代码拆分</h2>
<ul>
<li>为了使用一个方法加载一整个文件，消耗很大</li>
<li>可以使用js模块化（es6模块化）来进行，但是有的浏览器不太支持</li>
<li>使用webpack，支持es6模块化和commonJs</li>
</ul>
<h2 id="14-webpack竞品">1.4 webpack竞品</h2>
<ul>
<li>Parcel</li>
<li>vite（最新）</li>
<li>rollup</li>
</ul>
<h1 id="二-webpack基础应用">二、WebPack基础应用</h1>
<h2 id="21-webpack安装">2.1 webpack安装</h2>
<h3 id="全局安装">全局安装</h3>
<p><code>npm i webpack webpack-cli -g</code></p>
<h3 id="本地安装推荐">本地安装（推荐）</h3>
<p>首先使用 <code>npm init -y</code> 初始化项目<br>
<code>npm i webpack webpack-cli --save-dev</code></p>
<h2 id="22-运行">2.2 运行</h2>
<h3 id="使用全局webpack">使用全局webpack</h3>
<p><code>webpack</code></p>
<h3 id="使用本地webpack">使用本地webpack</h3>
<p><code>npx webpack</code></p>
<h2 id="23-自定义webpack配置">2.3 自定义webpack配置</h2>
<ul>
<li>使用<code>npx webpack --help</code>查看命令</li>
<li>但命令行不方便，可以使用配置文件</li>
<li>在项目根目录创建webpack.config.js(不能改名)</li>
</ul>
<h3 id="配置文件">配置文件</h3>
<pre><code>const path = require('path')
module.exports = {
	entry: './src/index.js',
	output: {
		filename: 'app.js',
		path: path.resolve(__dirname, 'dist')
	},
	module: {
		rules: [

		]
	},
	plugins: [

	],
	mode: 'development'
}

</code></pre>
<h2 id="24-核心概念">2.4 核心概念</h2>
<h3 id="entry-入口">Entry 入口</h3>
<p>指示 Webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。</p>
<h3 id="output-输出">Output 输出</h3>
<p>指示 Webpack 打包后的资源 bundles 输出到哪里，以及如何命名。</p>
<pre><code>module.exports = {
  ...
  output: {
    // 输出文件名称
    filename: 'app.js',
    // 输出文件路径
    path: path.resolve(__dirname, 'dist'),
    // 删除不需要的旧文件
    clean: true
  }
}
</code></pre>
<h3 id="module">module</h3>
<p>用于资源模块的打包</p>
<h3 id="loader-解析器">Loader 解析器</h3>
<ul>
<li>webpack只能理解js和json</li>
<li>让 Webpack 能够去处理那些非 JavaScript 文件 ( Webpack 自身只理解 JavaScript )。</li>
</ul>
<h3 id="plugins-插件">Plugins 插件</h3>
<p>可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。</p>
<h3 id="mode-模式">Mode 模式</h3>
<p>指示 Webpack 使用相应模式的配置。</p>
<ul>
<li>development 开发模式：会将 process.env.NODE_ENV 的值设为 development。启用 NameChunksPlugin 和 NameModulesPlugin。特点是能让代码本地调试运行的环境。</li>
<li>production 生产模式：会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin。特点是能让代码优化上线运行的环境。</li>
<li>none：</li>
</ul>
<h2 id="25-devserver">2.5 devServer</h2>
<h3 id="251-使用watch-model">2.5.1 使用watch model</h3>
<p><code>npx webpack --watch</code></p>
<ul>
<li>可以事实检测代码改变并重新打包</li>
<li>但是需要手动刷新浏览器</li>
</ul>
<h3 id="252-webpack-dev-server">2.5.2 webpack-dev-server</h3>
<ul>
<li>提供了一个基本的web server</li>
<li>具有live reloading（实时重新加载）功能</li>
</ul>
<h4 id="下载-webpack-dev-server">下载 webpack-dev-server</h4>
<p><code>npm i webpack-dev-server -D</code></p>
<h4 id="配置">配置</h4>
<pre><code>  devServer: {
    // 环境目录
    static: path.resolve(__dirname,'./dist'),
    // 设置是不是在服务器端进行代码 gzip 压缩，提高传输效率
    compress: true,
    // 设置服务器主机
    host: '0.0.0.0',
    // 设置端口号
    port: 3000,
    // 设置路由
    historyApiFallback: true,
    // 自动打开页面
    open: true,
    // 更改后自动更新
    watchFiles: {
      paths: [
        './*'
      ],
      options: {
        usePolling: false
      }
    },
    // 启用热加载功能
    liveReload: true,
    // 启用热模块功能
    hot: true，
    //设置响应头
    headers:{
        'X-Access-Token':'abc123'
    },
    //设置代理
    proxy:{
        '/api':'http://localhost:9000'
    },
    //配置https,让本地的http服务变成https服务
    https:true,
     //配置http2，http2自带https签名证书，我们仍然可以通过htps配置项来使用
    http2:true,
}
</code></pre>
<h4 id="启动">启动</h4>
<p><code>npx webpack-dev-server</code></p>
<h4 id="注意">注意</h4>
<p>webpack-dev-server不生成文件，而是保存在内存中，使得编译效率提高<br>
在 webpack.config.js 文件中进行配置</p>
<h2 id="26-资源模块">2.6 资源模块</h2>
<ul>
<li>webpack除了引入js还可以使用内置的资源模块</li>
<li>asset modules（资源模块）</li>
</ul>
<h3 id="261-资源模块分类">2.6.1 资源模块分类</h3>
<ul>
<li>asset/resource：发送一个单独的文件并导出 URL</li>
<li>asset/inline：导出一个资源的 Data URI ( 64位图 )</li>
<li>asset/source：导出资源的源代码</li>
<li>asset：在导出一个资源的 Data URI 和发送一个单独的文件之间自动进行选择</li>
</ul>
<h3 id="262-resource">2.6.2 resource</h3>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.png$/i,
        // 设置资源类型
        type: 'asset/resource',
        generator: {
          // 生成资源名称
          filename: 'assets/images/[name][ext]'
        }
      }
    ]
  }
}
</code></pre>
<ul>
<li>
<p>资源名称可以使用 [contenthash][ext] 将资源名称生成为 hash 值命名</p>
</li>
<li>
<p>还可以使用另一种方式打包，在output里面配置，但是generator优先级高</p>
</li>
</ul>
<pre><code>	output: {
		filename: 'app.js',
		path: path.resolve(__dirname, 'dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[name][ext]&quot;
	},
</code></pre>
<h3 id="263-inline">2.6.3 inline</h3>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.svg$/i,
        // 设置资源类型
        type: 'asset/inline'
      }
    ]
  }
}
</code></pre>
<h3 id="264-source">2.6.4 source</h3>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.txt$/i,
        // 设置资源类型
        type: 'asset/source'
      }
    ]
  }
}
</code></pre>
<h3 id="265-asset">2.6.5 asset</h3>
<ul>
<li>选择的依据是资源大小</li>
<li>默认情况下，资源大于8k使用asset/resource创建一个资源，小于8k，作为asset/inline生成base64的链接</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.jpg$/i,
        // 设置资源类型
        type: 'asset',
        // 小于设置的大小则转为 64 位图，否则转 URL
        parser: {
          dataUrlCondition: {
            maxSize: 4 * 1024 // 4kb
          }
        },
        generator: {
          // 生成资源名称
          filename: 'assets/images/[name][ext]'
        }
      }
    ]
  }
}
</code></pre>
<h2 id="27-资源处理">2.7 资源处理</h2>
<h3 id="271-html资源">2.7.1 HTML资源</h3>
<ol>
<li>下载 html-webpack-plugin 插件</li>
</ol>
<p><code>npm i html-webpack-plugin - D</code></p>
<ol start="2">
<li>在 webpack.config.js 文件中引入插件并调用</li>
</ol>
<pre><code>// 引用插件
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  ...
  plugins: [
    // 打包 HTML 文件
    new HtmlWebpackPlugin({
      // 指定 HTML 模版文件
      template: './index.html',
      //指定文件名
      filename:'app.html',
      // 指定 Script 标签位置
      inject: 'body'，
      //通过配置chunks来调整html引入的js
      chunks:['main']
    })
  ]
}
</code></pre>
<ul>
<li>Webpack 会在输出目录中新创建一个 HTML 文件，在原始的 HTML 文件中无需引入 JS 文件，通过 Webpack 编译后的 HTML 文件会自动引入。</li>
</ul>
<ol start="3">
<li>多页面环境</li>
</ol>
<ul>
<li>不同页面的filename必须不同</li>
<li>使用chunks指定引入不同的js</li>
</ul>
<pre><code>const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  ...
  plugins: [
    // 打包 HTML 文件
    new HtmlWebpackPlugin({
      template: './index.html',
      filename:'app.html',
      inject: 'body'，
      chunks:['main']，
      publicPath:'http://www.b.com'
    }),
      new HtmlWebpackPlugin({
      template: './index2.html',
      filename:'app2.html',
      inject: 'body'，
      chunks:['main2'],
      publicPath:'http://www.a.com'
    })
  ]
}
</code></pre>
<ul>
<li>还可以对打包好的的js路径进行</li>
</ul>
<pre><code>entry:{
    main:{
        import:['./src/app2.js','./src/app.js'],
        dependOn:'loadsh',
        filename:'chanel1/[name].js'
    },
    main:{
        import:['./src/app3.js'],
        dependOn:'loadsh',
        filename:'chanel2/[name].js'
    },
    lodash:{
        import:'lodash',
        filename:'common/[name].js'
    }
}
</code></pre>
<h3 id="272-样式资源">2.7.2 样式资源</h3>
<h4 id="打包css">打包css</h4>
<ul>
<li>下载样式处理解析器 css-loader 与 style-loader</li>
</ul>
<p><code>npm i css-loader style-loader -D</code></p>
<ul>
<li>在配置文件中添加解析器</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          // 在 head 中创建 style 标签
          'style-loader',
          // 将 css 文件整合到 js 文件中
          'css-loader'
        ]
      }
    ]
  }
}
</code></pre>
<ul>
<li>
<p>css-loader和style-loader的顺序不能颠倒，先执行css-loader，在执行style-loader。从后往前，webpack支持loader的链式调用，链式的每一个loader都可以对我们的源进行转换，且转换是逆序的</p>
</li>
<li>
<p>在 JS 文件中导入 CSS 文件</p>
</li>
</ul>
<p><code>import '../css/main.css'</code></p>
<h4 id="打包less">打包less</h4>
<ul>
<li>下载样式处理解析器 css-loader 与 style-loader</li>
</ul>
<p><code>npm i less-loader less -D</code></p>
<ul>
<li>在配置文件中添加解析器</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.(css|less)$/i,
        use: [
          // 在 head 中创建 style 标签
          'style-loader',
          // 将 css 文件整合到 js 文件中
          'css-loader',
         // 编译 less 文件为 css 文件
          'less-loader'
        ]
      }
    ]
  }
}
</code></pre>
<ul>
<li>在 JS 文件中导入 less文件</li>
</ul>
<p><code>import '../css/main.less'</code></p>
<h4 id="抽离和压缩css">抽离和压缩css</h4>
<p>抽离</p>
<ul>
<li>下载插件 mini-css-extract-plugin</li>
</ul>
<p><code>npm i mini-css-extract-plugin -D</code></p>
<ul>
<li>引用插件</li>
</ul>
<pre><code>const MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.s[ac]ss$/i,
        use: [
          // 抽离 css 为独立文件
          MiniCssExtractPlugin.loader,
          // 将 css 文件整合到 js 文件中
          'css-loader',
          // 编译 sass 文件为 css 文件
          'sass-loader'
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      // 对输出结果重命名
      filename: 'assets/css/[name].css'
    })
  ]
}
</code></pre>
<p>压缩</p>
<ul>
<li>
<p>安装插件 css-minimizer-webpack-plugin<br>
<code>npm i css-minimizer-webpack-plugin -D</code></p>
</li>
<li>
<p>在配置文件中进行配置</p>
</li>
</ul>
<pre><code>const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;)

module.exports = {
  ...
  optimization: {
    minimizer: [
      // 使用插件优化 css 代码
      new CssMinimizerPlugin()
    ],
  },
  // 模式
  mode: 'production'
}
</code></pre>
<ul>
<li>压缩 CSS 代码，仅在生产模式下有效</li>
<li>如果使用了css压缩，webpack开箱即用的terser会失效，那么要进行js压缩还要引入terser</li>
</ul>
<p>安装terser<br>
<code>npm install terser-webpack-plugin -D</code><br>
配置</p>
<pre><code>const TerserPlugin = require('terser-webpack-plugin')
	optimization: {
        minimizer:[
            new CssMinimizerPlugin(),
            new TerserPlugin()
        ]
		}
</code></pre>
<h3 id="273-css中加载图片资源">2.7.3 css中加载图片资源</h3>
<h3 id="274-加载fonts字体">2.7.4 加载fonts字体</h3>
<ul>
<li>通过 CSS 引入字体资源</li>
</ul>
<pre><code>@font-face {
  font-family: 'iconfont';
  src:url('../fonts/PujiSans-ExpandedHeavy.ttf') format('truetype')
}
.icon{
    font-family:'iconfont';
    font-size:30px;
}
</code></pre>
<ul>
<li>在 webpack.config.js 文件中进行配置</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        // 监听资源文件
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        // 设置资源类型
        type: 'asset/resource',
        generator: {
          // 生成资源名称
          filename: 'assets/fonts/[name][ext]'
        },
      }
    ]
  }
}
</code></pre>
<h3 id="275-加载数据">2.7.5 加载数据</h3>
<ul>
<li>安装插件</li>
</ul>
<p><code>npm i csv-loader xml-loader -D</code></p>
<ul>
<li>添加配置</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
          test:/\.(csv|tsv)$/,
          use:'csv-loader'
      },
      {
           test:/\.xml)$/,
           use:'xml-loader'
      }
    ]
  }
}
</code></pre>
<ul>
<li>.xml会转换为一个对象，.csv会转换为数组</li>
</ul>
<h3 id="276-自定义json模块">2.7.6 自定义json模块</h3>
<ul>
<li>安装</li>
</ul>
<p><code>npm i toml yaml json5 -D</code></p>
<ul>
<li>引入</li>
</ul>
<pre><code>const toml = require('toml')
const yaml = require('yaml')
const json5 = require('json5')
</code></pre>
<ul>
<li>添加配置</li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
          test:/\.toml$/,
          type:'json',
          parser:{
              parse:toml.parse
          }
      },
      {
          test:/\.yaml$/,
          type:'json',
          parser:{
              parse:yaml.parse
          }
      },
            {
          test:/\.json5$/,
          type:'json',
          parser:{
              parse:json5.parse
          }
      }
    ]
  }
}
</code></pre>
<h3 id="277-js资源">2.7.7 js资源</h3>
<h4 id="2771-js兼容处理">2.7.7.1 js兼容处理</h4>
<p>将 ES6 代码转换为低版本 ES 代码</p>
<p>安装模块</p>
<ul>
<li>babel-loader： 在 webpack 里应用 babel 解析 ES6 的桥梁</li>
<li>@babel/core： babel 核心模块</li>
<li>@babel/preset-env： babel 预设，一组 babel 插件的集合</li>
</ul>
<p><code>npm i babel-loader @babel/core @babel/preset-env -D</code><br>
在 package.json 中配置</p>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.js$/,
        // 排除 node_modules 中安装的库
        exclude: /(node_modules|bower_components)/,
        use: {
          // 加载 loader
          loader: 'babel-loader',
          options: {
            // 配置预设
            presets: ['@babel/preset-env']
          }
        }
      }
    ]
  }
}
</code></pre>
<h4 id="2772-regeneratorruntime">2.7.7.2 regeneratorRuntime</h4>
<ul>
<li>regeneratorRuntime 是 webpack 打包生成的全局辅助函数，由 babel 生成，用于兼容 async/await 的语法。<br>
<code>npm i @babel/runtime @babel/plugin-transform-runtime -D</code></li>
</ul>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.m?js$/,
        // 排除 node_modules 中安装的库
        exclude: /(node_modules|bower_components)/,
        use: {
          // 加载 loader
          loader: 'babel-loader',
          options: {
            // 配置预设
            presets: ['@babel/preset-env']
            plugins: [
              [
                '@babel/plugin-transform-runtime'
              ]
            ]
          }
        }
      }
    ]
  }
}
</code></pre>
<h4 id="2773-js语法检查">2.7.73 js语法检查</h4>
<p>使用 eslint 扫描我们所写的代码是否符合规范，严格意义上来说，eslint 配置跟 webpack 无关，但在工程化开发环境中，他往往是不可或缺的。</p>
<p>安装<br>
<code>npm i eslint -D</code><br>
创建配置文件，根据提示选择需要的类型。配置完成后，将在 node_modules 文件夹中生成一个 .eslintrc.json 文件，将文件复制到根目录下。<br>
<code>npx eslint --init</code><br>
<img src="https://star2399.github.io/post-images/1664709198238.png" alt="" loading="lazy"><br>
在 VSCode 中安装扩展 Eslint ，重启软件后将自动生效。</p>
<h4 id="2774-js-压缩">2.7.7.4 JS 压缩</h4>
<p>安装插件 terser-webpack-plugin</p>
<p><code>npm i terser-webpack-plugin -D</code></p>
<p>配置</p>
<pre><code>const TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;)

module.exports = {
  ...
  optimization: {
    minimizer: [
      // 使用插件压缩 js 代码 (生产模式)
      new TerserWebpackPlugin()
    ]
  }
}
</code></pre>
<h2 id="28-代码分离">2.8 代码分离</h2>
<ul>
<li>代码分离是webpack最引人注目的特性之一</li>
<li>可以把代码分离到不同的文件中</li>
<li>按需加载并行加载</li>
<li>可以获取更小的文件</li>
<li>控制资源加载的优先级</li>
</ul>
<h3 id="方法">方法</h3>
<ul>
<li>配置入口起点：使用entry手动分离代码 ，缺点是如果多个入口，那多个入口共享的文件会分别在每个包里重复打包</li>
<li>防止重复：使用Entry dependencies或者SplitChunksPlugin去重和分离代码</li>
<li>动态导入：通过模块的内联函数调用来分离代码</li>
</ul>
<h3 id="281-配置入口起点">2.8.1 配置入口起点</h3>
<ul>
<li>在src下创建新的入口文件another-module.js</li>
<li>entry配置如下：</li>
</ul>
<pre><code>entry:{
		index: './src/index.js',
		another:'./src/another-module.js'
},
</code></pre>
<ul>
<li>output配置如下</li>
</ul>
<pre><code>output: {
		filename: '[name].bundle.js',
		path: path.resolve(__dirname, 'dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[name][ext]&quot;
	}
</code></pre>
<ul>
<li>打包后发现index.html已经引入两个js且都有效</li>
<li>但是把公用的包分别打包到每个chunk里</li>
</ul>
<h3 id="282">2.8.2</h3>
<ul>
<li>entry如下编写,这样就会把公用的lodash提出来</li>
</ul>
<pre><code>	entry:{
		index: {
			import: './src/index.js',
			dependOn: 'shared'
		},
		another:{
			import: './src/another-module.js',
			dependOn: 'shared'
		},
		shared:'lodash'
	},
</code></pre>
<ul>
<li>也可以使用一个插件SplitChunksPlugin</li>
</ul>
<pre><code>    entry:{
            index: './src/index.js',
            another:'./src/another-module.js'
    },
	optimization: {
		splitChunks: {
			chunks: &quot;all&quot;
		}
	}
</code></pre>
<h3 id="283-动态导入">2.8.3 动态导入</h3>
<ul>
<li>编写async-module.js,动态导入lodash</li>
</ul>
<pre><code>function getComponment(){
	return import(/*webpackChunkName:'lodash'*/'lodash').then(({default:_})=&gt;{
		const element = document.createElement('div')
		element.innerHTML = _.join(['dasdasd','rrrrr'],' ')
		return element
	})
}

getComponment().then((element)=&gt;{
	document.body.appendChild(element)
})

</code></pre>
<ul>
<li>配置文件</li>
</ul>
<pre><code>	entry:{
		index: './src/index.js',
	},
</code></pre>
<ul>
<li>当又有静态资源时,打开如下配置：</li>
</ul>
<pre><code>	optimization: {
		splitChunks: {
			chunks: &quot;all&quot;
		}
	}
</code></pre>
<h3 id="284-动态加载应用-懒加载">2.8.4 动态加载应用-懒加载</h3>
<ul>
<li>编写math.js</li>
</ul>
<pre><code>export const add = (x,y)=&gt;{
	return x+y
}
export const minus = (x,y)=&gt;{
	return x-y
}

</code></pre>
<ul>
<li>在index.js中导入并编写如下代码</li>
</ul>
<pre><code>
const button = document.createElement('button')
button.textContent='点击执行加法运算'
button.addEventListener('click',()=&gt;{
	import(/*webpackChunkName:'math'*/'./math.js').then(({add})=&gt;{
		console.log(add(4,5))
	})
})
document.body.appendChild(button)

</code></pre>
<ul>
<li>打包后发现，不点击按钮就不会加载math.bundle.js，实现了懒加载</li>
</ul>
<h3 id="285-动态加载应用-预加载">2.8.5 动态加载应用-预加载</h3>
<p>在声明import时，使用下面的内置指令：</p>
<ul>
<li>prefetch（预获取）：将来某些导航下可能需要的资源，首页面的内容都加载完毕以后且网络空闲时，就会加载，比懒加载优秀</li>
</ul>
<pre><code>	import(/*webpackChunkName:'math',webpackPrefetch:true*/'./math.js').then(({add})=&gt;{
		console.log(add(4,5))
	})
</code></pre>
<ul>
<li>preload（预加载）：当前导航下可能需要的资源，和懒加载类似</li>
</ul>
<h2 id="29-缓存">2.9 缓存</h2>
<ul>
<li>在部署新版本时，不更改文件名，浏览器可能认为资源没有更新</li>
<li>本章通过一些设置，确保webpack生成的文件能被客户端缓存，在文件内容发生变化时能请求到新的文件</li>
</ul>
<h3 id="291-输出文件的文件名">2.9.1 输出文件的文件名</h3>
<p>使用contenthash，文件内容修改后文件名也会改变</p>
<pre><code>	output: {
		filename: '[name].[contenthash].js',
		path: path.resolve(__dirname, 'dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[contenthash][ext]&quot;
	},
</code></pre>
<h3 id="292-缓存第三方代码">2.9.2 缓存第三方代码</h3>
<ul>
<li>由于第三方代码保存在node_modules里，所以可以检测node_modules的代码</li>
</ul>
<pre><code>	optimization: {
		splitChunks: {
			cacheGroups: {
				vendor:{
					test: /[\\/]node_modules[\\/]/,
					name: 'vendors',
					chunks: &quot;all&quot;
				}
			}
		}
	}
</code></pre>
<h3 id="293-把所有的js放进一个文件夹里">2.9.3 把所有的js放进一个文件夹里</h3>
<pre><code>	output: {
		filename: 'scripts/[name].[contenthash].js',
		path: path.resolve(__dirname, 'dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[contenthash][ext]&quot;
	},
</code></pre>
<h2 id="210-拆分开发环境和生产环境配置">2.10 拆分开发环境和生产环境配置</h2>
<h3 id="2101-公共路径">2.10.1 公共路径</h3>
<p>在output里添加如下配置</p>
<pre><code>	output: {
		publicPath: &quot;http://localhost:8080/&quot;
	},
</code></pre>
<h3 id="2102-环境变量">2.10.2 环境变量</h3>
<ul>
<li>环境变量可以帮助我们消除webpack.config.js里面开发环境和生产环境之间的差异</li>
<li>使用环境变量需要我们把webpack.config.js暴露的对象百年城一个函数，函数返回之前的配置对象，函数接受的参数就是env</li>
</ul>
<pre><code>module.exports = (env)=&gt;{
	return {
		entry:{
		},
		output: {
		},
		devtool: 'inline-source-map',
		module: {
			rules: [
			]
		},
		plugins: [
		],
		mode: 'development',
		devServer: {
			// 环境目录
			static: './dist',
		},
		optimization: {
		}
	}

}

</code></pre>
<h3 id="2103-拆分配置文件">2.10.3 拆分配置文件</h3>
<ul>
<li>如果所有开发环境和是生产环境的区别都用三元运算符，会很麻烦</li>
<li>在项目根目录下创建config文件夹，创建webpcak.config.dev.js和webpcak.config.prod.js，代码分别如下：</li>
</ul>
<p>webpcak.config.dev.js</p>
<pre><code>// webpack.config.js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports = {
	entry:{
		index: './src/index.js',
		another:'./src/another-module.js'
	},
	output: {
		filename: 'scripts/[name].js',
		path: path.resolve(__dirname, '../dist'),
		clean: true,
		assetModuleFilename: &quot;assets/images/[contenthash][ext]&quot;,
	},
	devtool: 'inline-source-map',
	module: {
		rules: [
			{
				// 监听资源文件
				test: /\.png$/i,
				// 设置资源类型
				type: 'asset/resource',
				generator: {
					// 生成资源名称
					filename: 'assets/images/[name][ext]'
				}
			},
			{
				// 监听资源文件
				test: /\.svg$/i,
				// 设置资源类型
				type: 'asset/inline'
			},
			{
				// 监听资源文件
				test: /\.txt$/i,
				// 设置资源类型
				type: 'asset/source'
			},
			{
				// 监听资源文件
				test: /\.jpg$/i,
				// 设置资源类型
				type: 'asset',
				// 小于设置的大小则转为 64 位图，否则转 URL
				parser: {
					dataUrlCondition: {
						maxSize: 4 * 1024 // 4kb
					}
				},
				generator: {
					// 生成资源名称
					filename: 'assets/images/[name][ext]'
				}
			},
			{
				test: /\.css$/i,
				use: [
					MiniCssExtractPlugin.loader,
					// 在 head 中创建 style 标签
					// 将 css 文件整合到 js 文件中
					'css-loader'
				]
			},
			{
				test: /\.js$/,
				// 排除 node_modules 中安装的库
				exclude: /(node_modules|bower_components)/,
				use: {
					// 加载 loader
					loader: 'babel-loader',
					options: {
						// 配置预设
						presets: ['@babel/preset-env'],
						plugins: [
							[
								'@babel/plugin-transform-runtime'
							]
						]
					}
				}
			}
		]
	},
	plugins: [
		new HtmlWebpackPlugin({
			// 指定 HTML 模版文件
			template: './index.html',
			// 指定 Script 标签位置
			inject: 'body'
		}),
		new MiniCssExtractPlugin({
			// 对输出结果重命名
			filename: 'assets/css/[name].css'
		})
	],
	mode: 'development',
	devServer: {
		// 环境目录
		static: './dist',
	},
	optimization: {
		splitChunks: {
			cacheGroups: {
				vendor:{
					test: /[\\/]node_modules[\\/]/,
					name: 'vendors',
					chunks: &quot;all&quot;
				}
			}
		}
	}
}
</code></pre>
<p>webpcak.config.prod.js</p>
<pre><code>// webpack.config.js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports ={
		entry:{
			index: './src/index.js',
			another:'./src/another-module.js'
		},
		output: {
			filename: 'scripts/[name].[contenthash].js',
			path: path.resolve(__dirname, '../dist'),
			clean: true,
			assetModuleFilename: &quot;assets/images/[contenthash][ext]&quot;,
			publicPath: &quot;http://localhost:8080/&quot;
		},
		module: {
			rules: [
				{
					// 监听资源文件
					test: /\.png$/i,
					// 设置资源类型
					type: 'asset/resource',
					generator: {
						// 生成资源名称
						filename: 'assets/images/[name][ext]'
					}
				},
				{
					// 监听资源文件
					test: /\.svg$/i,
					// 设置资源类型
					type: 'asset/inline'
				},
				{
					// 监听资源文件
					test: /\.txt$/i,
					// 设置资源类型
					type: 'asset/source'
				},
				{
					// 监听资源文件
					test: /\.jpg$/i,
					// 设置资源类型
					type: 'asset',
					// 小于设置的大小则转为 64 位图，否则转 URL
					parser: {
						dataUrlCondition: {
							maxSize: 4 * 1024 // 4kb
						}
					},
					generator: {
						// 生成资源名称
						filename: 'assets/images/[name][ext]'
					}
				},
				{
					test: /\.css$/i,
					use: [
						MiniCssExtractPlugin.loader,
						// 在 head 中创建 style 标签
						// 将 css 文件整合到 js 文件中
						'css-loader'
					]
				},
				{
					test: /\.js$/,
					// 排除 node_modules 中安装的库
					exclude: /(node_modules|bower_components)/,
					use: {
						// 加载 loader
						loader: 'babel-loader',
						options: {
							// 配置预设
							presets: ['@babel/preset-env'],
							plugins: [
								[
									'@babel/plugin-transform-runtime'
								]
							]
						}
					}
				}
			]
		},
		plugins: [
			new HtmlWebpackPlugin({
				// 指定 HTML 模版文件
				template: './index.html',
				// 指定 Script 标签位置
				inject: 'body'
			}),
			new MiniCssExtractPlugin({
				// 对输出结果重命名
				filename: 'assets/css/[name].css'
			})
		],
		mode:'production',
		optimization: {
			splitChunks: {
				cacheGroups: {
					vendor:{
						test: /[\\/]node_modules[\\/]/,
						name: 'vendors',
						chunks: &quot;all&quot;
					}
				}
			}
		}


}

</code></pre>
<p>分别使用命令运行:<br>
<code>npx webpack -c ./config/webpack.config.dev.js</code><br>
<code>npx webpack -c ./config/webpack.config.prod.js</code></p>
<h3 id="2104-配置npm脚本">2.10.4 配置npm脚本</h3>
<p>在项目根目录下的package.json输入如下脚本</p>
<pre><code>
{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;npx webpack -c ./config/webpack.config.dev.js&quot;,
    &quot;build&quot;: &quot;npx webpack -c ./config/webpack.config.prod.js&quot;
  }
}

</code></pre>
<p>关闭性能提示：</p>
<pre><code>	performance: {
			hints: false
	}
</code></pre>
<h3 id="2105-提取公共配置">2.10.5 提取公共配置</h3>
<ul>
<li>拆分文件，把公共部分写道webpack.config.common.js</li>
<li>其他两个文件的公共部分删除</li>
<li>安装工具</li>
</ul>
<p><code> npm install webpack-merge -D</code></p>
<ul>
<li>在config下创建webpack.config.js，编写如下配置</li>
</ul>
<pre><code>const {merge} = require('webpack-merge')

const commonConfig = require('./webpack.config.common')
const productionConfig = require('./webpack.config.prod')
const developmentConfig = require('./webpack.config.dev')

module.exports = (env)=&gt;{
	switch (true){
		case env.development:
			return merge(commonConfig,developmentConfig)
		case env.production:
			return merge(commonConfig,productionConfig)
		default:
			return new Error('No matching configuration was found')
	}
}
</code></pre>
<ul>
<li>修改package.json的script</li>
</ul>
<pre><code>  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack serve -c ./config/webpack.config.js --env development&quot;,
    &quot;build&quot;: &quot;webpack -c ./config/webpack.config.js --env production&quot;
  }
</code></pre>
<h1 id="三-webpack高级应用">三、WebPack高级应用</h1>
<h2 id="31-提高开发效率与完善团队开发规范">3.1 提高开发效率与完善团队开发规范</h2>
<h3 id="311-source-map">3.1.1 source-map</h3>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>这是默认情况，每个module会封装到eval里包裹起来执行，并在末尾追加注释//sourceURL指向未打包的文件。<strong>此时会显示webpack打包前代码的位置</strong></td>
</tr>
<tr>
<td>source-map</td>
<td>生成一个SourceMap文件，<strong>其他功能同eval</strong>。打包好的main.js最后会有一个指向该SourceMap文件的URL</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>生成一个DataUrl形式的（不是单独生成SourceMap文件）SourceMap作为注释放在打包好的js文件末尾，任然<strong>会显示webpack打包前代码的位置</strong></td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>和source-map一样。但不会在末尾追加注释，还是会生成SourceMap文件。<strong>无法显示webpack打包前代码的位置</strong></td>
</tr>
<tr>
<td>eval-source-map</td>
<td>每个module会通过eval()来执行,并且生成一个DataUrl形式的SourceMap文件 （不是单独生成SourceMap文件），<strong>会显示webpack打包前代码的位置</strong></td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>生成一个没有列信息的SourceMap文件，<strong>会显示webpack打包前代码的行位置</strong>。但是<strong>对与使用过babel解析过的代码不能定位列数</strong></td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>生成一个没有列信息的SourceMap文件，<strong>对与使用过babel解析过的代码能定位列数</strong>，开发环境推荐使用</td>
</tr>
</tbody>
</table>
<p>生产环境不推荐使用sourcemap，原因如下：</p>
<ul>
<li>通过bundle和sourcemap，可以反编译出源码，有暴露源码的风险</li>
<li>sourcemap文件的体积比较大，这和我们生产环境的追求不同</li>
</ul>
<h3 id="312-模块热替换hmr-hot-modult-replacement和热加载">3.1.2 模块热替换（HMR hot modult replacement）和热加载</h3>
<h4 id="开启热替换默认是开启的">开启热替换(默认是开启的)</h4>
<pre><code>decServer:{
    hot:true
}
</code></pre>
<ul>
<li>css热替换可以直接进行(css-loader帮助我们完成了)</li>
<li>js需要在引用需要热替换的文件中添加如下代码</li>
</ul>
<pre><code>if(module.hot){
    module.hot.accept('./input.js',()=&gt;{

    })
}
</code></pre>
<h4 id="开启热加载默认是开启的如果要关闭需要在把livereload视之为false的同时hot也设置为false">开启热加载(默认是开启的)，如果要关闭，需要在把liveReload视之为false的同时hot也设置为false</h4>
<ul>
<li>热加载相当于可以自动刷新，不用手动刷新</li>
</ul>
<pre><code>decServer:{
    liveReload:true
}
</code></pre>
<h3 id="313-eslint">3.1.3 ESLint</h3>
<ul>
<li>可以扫描i哦代码是否符合规范</li>
</ul>
<h4 id="安装">安装</h4>
<p><code>npm i eslint -D</code></p>
<h4 id="创建eslint的配置文件">创建eslint的配置文件</h4>
<p><code>npx eslint --init</code></p>
<h4 id="直接使用">直接使用</h4>
<p><code>npx eslint ./app.js</code></p>
<h4 id="配合vscode使用">配合vscode使用</h4>
<p>在vscode里安装插件</p>
<h4 id="配合webpack使用">配合webpack使用</h4>
<pre><code>module:{
    rules:[
        {
                test:/\.js$/,
                use:['babel-loader','eslint-loader']
        }
    ]
}
</code></pre>
<p>此时浏览器也会报错，如果不想浏览器显示的话，可以添加如下配置：</p>
<pre><code>devServer:{
    client:{
        overlay:false
    }
}
</code></pre>
<h3 id="314-git-hooks与husky">3.1.4 git-hooks与husky</h3>
<p>团队开发中一般在上传代码时进行校验</p>
<h4 id="git-hooks使用步骤如下">git-hooks使用步骤如下</h4>
<ul>
<li>.git文件夹下的hooks下有很多扩展名为.sample的文件</li>
<li>这些文件都是git的hook，会在git的不同生命周期调用</li>
<li>可以在pre-commit文件里面运行eslint</li>
<li>创建pre-commit    <code>touch pre-commit</code></li>
<li>编辑pre-commit    <code>npx eslint ./src</code></li>
<li>给pre-commit赋予权限，<code>chmod +x ./pre-commit</code></li>
<li>下次git再提交时就会运行pre-commit里面的命令</li>
</ul>
<p>但是，.git每个开发者都不一样，也没办法放在git仓库里，可以如下做</p>
<ul>
<li>在项目根目录里创建.mygithooks</li>
<li>在.mygithooks里创建pre-commit</li>
<li>编辑pre-commit    <code>npx eslint ./src</code></li>
<li>修改githooks的执行lujing  <code>git config core.hooksPath .mygithooks</code></li>
<li>给pre-commit赋予权限，<code>chmod +x .mygithooks/pre-commit</code></li>
</ul>
<h4 id="使用husky">使用husky</h4>
<ul>
<li>安装：<code>npm i husky -D</code></li>
<li>执行：<code>npx husky install</code></li>
<li>配置package.json,添加script脚本</li>
</ul>
<pre><code>scripts:{
    &quot;prepare&quot;:&quot;husky install&quot;
}
</code></pre>
<ul>
<li>在.husky文件下添加pre-commit</li>
<li>编辑pre-commit    <code>npx eslint ./src</code></li>
<li>给pre-commit赋予权限</li>
</ul>
<h2 id="32-模块与依赖">3.2 模块与依赖</h2>
<h3 id="321-模块解析">3.2.1 模块解析</h3>
<p>webpack通过Resolvers实现了模块之间的依赖和引用<br>
所引用的模块可以是来自应用程序的代码，也可以是第三方库。resolver帮助webpack从每个require/import语句中，找到需要引入到bundle中的代码模块。当打包模块时，webpack使用enhanced-resolve来解析文件路径。</p>
<h4 id="解析绝对路径">解析绝对路径</h4>
<h4 id="解析相对路径">解析相对路径</h4>
<h4 id="解析模块路径">解析模块路径</h4>
<h4 id="使用别名来优化">使用别名来优化</h4>
<p>在webpack.config.js下加入如下配置：</p>
<pre><code>const path = require('path')
resolve:{
    alias:{
        '@':path.resolve(__dirname,'./src')
    },
    extensions:['.json','.js','.vue']//配置加载模块的顺序
}
</code></pre>
<h3 id="322-外部扩展">3.2.2 外部扩展</h3>
<p>比如我们想引入jquery，那么在webpack.config.js中配置：</p>
<pre><code>externalsType:'script',
externals:{
    jquery:[//这个jquery就是import的名字
        '//这里写cdn链接'，
        '$'//表示script标签在浏览器上暴露的对象
    ]
}
</code></pre>
<h3 id="323-依赖图">3.2.3 依赖图</h3>
<p>每当一个文件依赖另一个文件时，webpack 会直接将文件视为存在依赖关系。这使 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把他们作为依赖提供给应用程序。当 webpack 开始工作时，它会根据我们写好的配置，从入口 (Entry) 开始，webpack 会递归的构建一个依赖关系图，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为输出文件。</p>
<ul>
<li>webpack-chart：webpack stats 可交互饼图；</li>
<li>webpack-visualizer：可视化并分析你的bundle，检查哪些模块占用空间，哪些可能使重复使用的；</li>
<li>webpack-bundle-analyzer：一个 plugin 和 CLI 工具，它将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式；</li>
<li>webpack bundle optimize helper：分析你的bundle并提供可操作的改进措施，减少 bundle 的大小；</li>
<li>bundle-stats：生成一个 bundle 报告 ( bundle大小、资源、模块 )，并比较不同构建之间的结果。</li>
</ul>
<h4 id="webpack-bundle-analyzer使用">webpack-bundle-analyzer使用</h4>
<ul>
<li>下载webpack-bundle-analyzer <code>npm i  webpack-bundle-analyzer -D</code></li>
<li>配置webpack.config.js</li>
</ul>
<pre><code>const {BundleAnalyzerPlugin} = require('webpack-bundle-analyzer')


module.exports={
	plugins:[
		new BundleAnalyzerPlugin()
	]
}
</code></pre>
<h2 id="33">3.3</h2>
<h3 id="331-postcss与css模块">3.3.1 PostCSS与CSS模块</h3>
<p><strong>PostCSS</strong> 是一个用javascript工具和插件转换css代码的工具。比如可以使用Autoprefixer插件自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮我们自动的为css规则添加前缀<br>
<strong>CSS模块</strong>能让你永远不用担心命名太大众化而造成的冲突，只要用最有意义的名字就行了</p>
<h4 id="postcss">PostCSS</h4>
<ul>
<li>安装：<code>npm i postcss-loader -D</code></li>
<li>修改配置文件</li>
</ul>
<pre><code>  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          'style-loader',
          'css-loader',
          'postcss-loader'
        ]
      }
    ]
  }
</code></pre>
<ul>
<li>安装插件：<code>npm i autoprefixer -D</code></li>
<li>项目根目录下创建postcss.config.js并编写如下配置</li>
</ul>
<pre><code>module.exports={
    plugins:[
        require('autoprefixer')
    ]
}
</code></pre>
<ul>
<li>在package.json添加如下配置</li>
</ul>
<pre><code>&quot;browserslist&quot;:[
    &quot;&gt;1%&quot;,
    &quot;last 2 versions&quot;
]
</code></pre>
<ul>
<li>安装插件：<code>npm i postcss-nested -D</code>,可以使用嵌套样式</li>
<li>编写postcss.config.js</li>
</ul>
<pre><code>module.exports={
    plugins:[
        require('autoprefixer'),
        require('postcss-nested')
    ]
}
</code></pre>
<h4 id="css模块">css模块</h4>
<pre><code>  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          'style-loader',
          {
              loader:'css-loader',
              options:{
                  modules:true
              }
          },
          'postcss-loader'
        ]
      }
    ]
  }
</code></pre>
<ul>
<li>
<p>在js中引入css时可以向模块化一样引入<code>import style from './app.css'</code></p>
</li>
<li>
<p>使用时直接用style.box,值是一个唯一的值，不用担心冲突</p>
</li>
<li>
<p>也可以部分开启css模块样式，全局样式加上.global前缀，如</p>
<ul>
<li>.global.css 普通模式，用 new RegExp(<code>^(?!.*\\.global).*\\.css</code>)</li>
<li>.css module模式，用 new RegExp(<code>^(.*\\.global).*\\.css</code>)</li>
</ul>
</li>
<li>
<p>在定义module时进行两种不同的正则匹配</p>
</li>
</ul>
<h3 id="332-web-workers">3.3.2 Web Workers</h3>
<p>Web Workers提供了js的后台处理线程的api，允许我们将复杂的、耗时的、单纯的js处理逻辑放在浏览器的后台线程中进行处理，让js线程不阻塞UI线程渲染。webpack5内置了打包WebWorker这个功能</p>
<ul>
<li>编写一个worker.js</li>
</ul>
<pre><code>self.onmessage=(message)=&gt;{
    self.postMessage({
        answer:1111
    })
}
</code></pre>
<ul>
<li>app.js里面编写如下代码</li>
</ul>
<pre><code>const worker= new Worker(new URL('./work.js',import.meta.url))
work.postMessage({
    question:'hi,那边的worker线程，请告诉我今天的幸运数字输多少？'
})

worker.onmessage=(message)=&gt;{
    console.log(message.data.answer)
}
</code></pre>
<h3 id="333-typescript">3.3.3 Typescript</h3>
<h4 id="安装-2">安装</h4>
<p><code>npm i typescript ts-loader -D</code></p>
<h4 id="配置-2">配置</h4>
<pre><code>module.exports={
    devtool:'inline-source-map',
    module:{
        rules:[
            {
                test:/\.ts$/,
                use:'ts-loader',
                exclude://node_modules
            }
        ]
    },
    resolve:{
        extensions:['.ts','.js']
    }
}
</code></pre>
<h4 id="创建ts配置文件">创建ts配置文件</h4>
<p>项目根目录下执行<code>npx tsc --init</code>,自动生成tsconfig.json<br>
修改配置文件,添加如下配置：</p>
<pre><code>&quot;rootDir&quot;:&quot;./src&quot;,
&quot;outDir&quot;:&quot;./dist&quot;
</code></pre>
<h2 id="34-tree-shaking">3.4 tree-shaking</h2>
<h3 id="341什么是tree-shaking">3.4.1什么是tree-shaking</h3>
<ul>
<li>把没有用的代码全部删掉</li>
<li>webpack不能百分百进行tree-shaking，有些模块导入了就会有严重的影响（有副作用）</li>
<li>所以具有副作用的文件不应该被tree-shaking,比如说样式文件虽然导入没有使用，但是依然会产生作用，所以不应该被tree-shaking</li>
<li>配置如下</li>
</ul>
<pre><code>optimization:{
    usedExports:true
}
</code></pre>
<h3 id="342-sideeffects">3.4.2 sideEffects</h3>
<p>可以在package.json里面设置副作用</p>
<pre><code>&quot;sideEffects&quot;:true//表示所有文件都有副作用，都不会被tree-shaking
&quot;sideEffects&quot;:false//表示所有文件都没有副作用，都会被tree-shaking
&quot;sideEffects&quot;:[&quot;*.css&quot;]//表示数组内所有文件都有副作用，都不会被tree-shaking
</code></pre>
<h2 id="35-渐进式网络应用程序pwa">3.5 渐进式网络应用程序（PWA）</h2>
<ul>
<li>最主要的时在离线情况下应用程序能够继续运行</li>
</ul>
<h3 id="351-使用http-server">3.5.1 使用http-server</h3>
<ul>
<li>安装:<code>npm i http-server -D</code></li>
<li>配置：</li>
</ul>
<pre><code>  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;http-server dist&quot;
  },
</code></pre>
<ul>
<li>运行：<code>npm run start</code></li>
</ul>
<h3 id="352-使用webpack-dev-server">3.5.2 使用webpack-dev-server</h3>
<ul>
<li>安装:<code>npm i webpack-dev-server -D</code></li>
<li>配置：</li>
</ul>
<pre><code>devServer：{

}
</code></pre>
<ul>
<li>运行：<code>npx webpack serve</code></li>
<li>webpack-dev-server执行是保存在内存中的，如果想要改变打包的结果需要重新打包，或者如下配置：</li>
</ul>
<pre><code>devServer：{
    devMiddleware:{
        writeToDisk:true
    }
}
</code></pre>
<h3 id="353-pwa">3.5.3 PWA</h3>
<ul>
<li>无论是http-server还是webpack-dev-server，当服务器停止后都无法访问页面</li>
<li>安装work-box来实现pwa：<code>npm i workbox-webpack-plugin -D</code></li>
<li>使用插件</li>
</ul>
<pre><code>const WorkboxPlugin = require('workbox-webpack-plugin')
plugins:[
    new WorkboxPlugin.GenerateSW({
        clientsClaim:true,
        skipWaiting:true
    })
]
</code></pre>
<ul>
<li>浏览器中也要做相应的配置</li>
</ul>
<pre><code>if('serviceWorker' in navigator){
	window.addEventListener('load',()=&gt;{
		navigator.serviceWorker.register('/service-worker.js')
			.then(registration=&gt;{
				console.log('SW 注册成功：',registration)
			})
			.catch(registrationError=&gt;{
				console.log('SW 注册失败：',registrationError)
			})
	})
}

</code></pre>
<ul>
<li>此时发现，即使服务器关闭也可以访问网页。主要是应用了缓存</li>
</ul>
<h2 id="36-shimming预制依赖">3.6 Shimming预制依赖</h2>
<h3 id="361-shimming用处">3.6.1 shimming用处</h3>
<ul>
<li>一些第三方库会创建一些需要导出的全局变量，这些不合规范的模块也就是shimming发挥作用的地方</li>
<li>当希望polyfills，也就是扩展浏览器能力能够支持更多用户时，只需要把polyfills提供给需要修补的用户，也就是实现按需加载</li>
</ul>
<h3 id="362-shimming预制全局变量">3.6.2 shimming预制全局变量</h3>
<ul>
<li>如果遇到下划线，把lodash的包提供给他</li>
</ul>
<pre><code>const webpack = require('webpack')
plugins:[
    new webpack.ProvidePlugin({
        _:'lodash'
    })
]
</code></pre>
<h3 id="363-细颗粒度的shimming">3.6.3 细颗粒度的shimming</h3>
<ul>
<li>在commonJS上下文中，this指向的是module.exports，而不是window。那么执行this.alert('ss')会报错。可以使用imports-loader来覆盖this的指向</li>
<li>安装：<code>npm i imports-loader -D</code></li>
<li>修改配置文件</li>
</ul>
<pre><code>module:{
    rules:[
        {
            test:require.resolve('./src/index.js'),
            use:'imports-loader?wrapper=window'
        }
    ]
}
</code></pre>
<h3 id="364-全局export">3.6.4 全局Export</h3>
<ul>
<li>安装：<code>npm i exports-loader -D</code></li>
<li>配置：</li>
</ul>
<pre><code>module:{
    rules:[
        {
            test:require.resolve('./src/globals.js'),
            use:'exports-loader?type=commonjs&amp;exports=file,multiple|helpers.parse|parse'
        }
    ]
}
</code></pre>
<ul>
<li>用途：global.js是外部的文件，一般情况下我们不知道他是如何导出的</li>
</ul>
<h3 id="365-加载polyfills">3.6.5 加载Polyfills</h3>
<ul>
<li>用处：可以进行<strong>优雅降级</strong></li>
<li>安装：<code>npm i --save @babel/polyfill</code></li>
<li>在对应的js中使用：<code>import @babel/polyfill</code></li>
</ul>
<h3 id="366-进一步优化polyfills">3.6.6 进一步优化Polyfills</h3>
<ul>
<li>不建议使用<code>import @babel/polyfill</code>。因为这样会在全局引入整个polyfill包。不但包体积大，而且还会污染全局变量</li>
<li>bable-preset-env通过browserslist来转译浏览器中不支持的特性。这个preset使用useBuiltIns选项，默认值是false，这种方式可以把全局导入的babel-polyfill改进为更细粒度的import格式</li>
<li>安装@babel/preset-env及i相关的包</li>
</ul>
<p><code>npm i babel-loader @babel/core @babel/preset-env -D</code><br>
<code>npm i core-js@23 -D</code></p>
<ul>
<li>修改配置文件</li>
</ul>
<pre><code>rules:[
    {
        test:/\.js$/,
        exclude:/node_modules/,
        use:{
            loader:'babel-loader',
            options:{
                presets:[
                    [
                        '@babel/preset-env',
                        {
                            targets:[
                                'last 1 version',
                                '&gt;1%'
                            ],
                            useBuiltIns:'usage',
                            corejs:3
                        }
                    ]
                ]
            }
        }
    }
]
</code></pre>
<h2 id="37-创建library">3.7 创建Library</h2>
<p>让代进行Library打包，因该这样配置</p>
<pre><code>output:{
    library:{
        name:'mylib',
        type:'window'//还可以是commonjs，module，umd
    }
}
</code></pre>
<p><strong>注意</strong></p>
<ul>
<li>es6模块化还处于试用阶段，所以需添加配置</li>
</ul>
<pre><code>experiments:{
    outputModule:true
}
</code></pre>
<ul>
<li>es6模块化不能设置name，引入时要解构赋值</li>
<li>umd的library可以支持scripts标签、commonjs和amd，其中使用commonjs时需要修改配置文件,且引用时需要解构赋值</li>
</ul>
<pre><code>output:{
    library:{
        name:'mylib',
        type:'window'//还可以是commonjs，module，umd
    },
    globalObject:'globalThis'
}
</code></pre>
<h2 id="38-模块联邦">3.8 模块联邦</h2>
<p>假如我们现在有三个应用，nav，home，search<br>
现在nav的webpack.config.js里面做如下配置</p>
<pre><code>const {ModuleDederationPlugin} = require('webpack').container
module.exports={
    plugins:[
        new ModuleDederationPlugin({
            //标识模块联邦的名字
            name:'nav',
            //使用这个模块联邦的应用
            filename:'remoteEntry.js',
            //引用其他应用暴露的组件
            remotes:{},
            //我们要暴露的
            exposes:{
                './Header':'./src/Header.js'
            },
            //共享的，单独打包
            shared:{}
        })
    ]
}
</code></pre>
<p>在home组件里面使用模块联邦</p>
<pre><code>const {ModuleDederationPlugin} = require('webpack').container
module.exports={
    plugins:[
        new ModuleDederationPlugin({
            //标识模块联邦的名字
            name:'nav',
            //使用这个模块联邦的应用
            filename:'remoteEntry.js',
            //引用其他应用暴露的组件
            remotes:{
                nav:'nav@http://localhost:3003/remoteEntry.js'
            },
            //我们要暴露的
            exposes:{},
            //共享的，单独打包
            shared:{}
        })
    ]
}
</code></pre>
<p>在index.js里面引入</p>
<pre><code>import('nav/Header').then((Header)=&gt;{
    const body = document.createElement('div')
    body.appendChild(Header.default())
})
</code></pre>
<h2 id="39-提升构建性能">3.9 提升构建性能</h2>
<h3 id="391-通用环境优化">3.9.1 通用环境优化</h3>
<ol>
<li>更新到最新版本（webpack，node，npm，yarn）</li>
<li>将loader应用于最小数量的必要模块</li>
<li>引导（bootstrap），每个额外的loader/plugin都有其启动时间，尽量少的使用工具</li>
<li>解析：
<ol>
<li>减少resolve.modules,resolve.extensions,resolve.mainFiles,resolve.description中条目数量，因为他们会增加文件系统调用次数</li>
<li>如果不使用symlinks，可以设置resolve.symlinks:false</li>
<li>如果使用自定义resolve plugin规则，并且没有指定context上下文，可以设置resolve.cacheWithContext:false</li>
</ol>
</li>
<li>小就是快，减少编译结果整体大学校，以提高构建性能。尽量保持chunk体积小。
<ol>
<li>使用数量更少/体积更小的library</li>
<li>在多页面应用程序中使用SplitChunksPlugin，并开启asunc模式</li>
<li>移除未引用代码</li>
<li>只编译当前正在开发的那些代码</li>
</ol>
</li>
<li>持久化缓存：在webpack配置中使用cache选项。使用package.json中的&quot;postinstall&quot;清除缓存目录。将cache类型设置为内存或者文件系统。memory选项很简单。它告诉webpack在内存中缓存，不允许额外的配置。</li>
<li>自定义plugin/loader时，要对他们进行分析，避免性能问题</li>
<li>progress plugin：删除progress plugin会缩短构建时间。但是不会缩短太多，请权衡利弊</li>
<li>dll：使用dllplugin为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管她增加了构建过程的复杂度</li>
<li>worker池：thread-loader可以将非常消耗资源的loader分流给一个worker pool</li>
</ol>
<h3 id="392-dll">3.9.2 dll</h3>
<ol>
<li>下载好第三方库后，使用 import 语法在 JS 文件中引入文件<br>
<code>import _ from 'jquery';</code></li>
<li>在根目录中创建 webpack.dll.config.js</li>
</ol>
<pre><code>const path = require('path');
const Webpack = require('webpack');

module.exports = {
  entry: {
    jquery: ['jquery'],
  },
  output: {
    // 输出文件名称
    filename: '[name].js',
    // 输出文件路径
    path: path.resolve(__dirname, '../dll'),
    // 导出库名称
    library: '[name]_[hash]',
  },
  plugins: [
    // 引入插件
    new Webpack.DllPlugin({
      // 对应导出的库名称
      name: '[name]_[hash]',
      // 生成 manifest 文件
      path: path.resolve(__dirname, '../dll/manifest.json'),
    }),
  ],
  mode: 'production',
}
</code></pre>
<ol start="3">
<li>在 package.json 中编辑</li>
</ol>
<pre><code>&quot;scripts&quot;: {
  &quot;dll&quot;: &quot;webpack --config ./webpack.dll.config.js&quot;
}
</code></pre>
<ol start="4">
<li>执行指令</li>
</ol>
<p><code>npm run dll</code><br>
5. 然后配置 webpack.config.js 文件</p>
<pre><code>const path = require('path')
const Webpack = require('webpack')

module.exports = {
  ...
  plugins: [
    // 告诉 webpack 哪些库布参与打包，以及使用的名称
    new Webpack.DllReferencePlugin({
      manifest: path.resolve(__dirname, 'dll/manifest.json')
    })
  ]
}
</code></pre>
<ol start="6">
<li>如需在页面中自动引用，需安装一个插件 add-asset-html-webpack-plugin，再在 webpack.config.js 文件中进行配置</li>
</ol>
<p><code>npm i add-asset-html-webpack-plugin -D</code></p>
<pre><code>const path = require('path')
const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')

module.exports = {
  ...
  plugins: [
    // 在html中自动引入
    new AddAssetHtmlWebpackPlugin({
      filepath: path.resolve(__dirname, 'dll/gsap.js'),
      publicPath: './'
    })
  ]
}
</code></pre>
<h3 id="393-worker-pool">3.9.3 worker pool</h3>
<ol>
<li>安装：<code>npm i babel-loader @babel/core @babel/preset-env -D</code></li>
<li>安装worker pool需要的依赖：<code>npm i thread-loader -D</code></li>
<li>配置</li>
</ol>
<pre><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /(node_modules)/,
        use: [
            {
                loader: 'babel-loader',
                options: {
                    presets: ['@babel/preset-env']
                }
            },
            {
                loader:'thread-loader',
                options:{
                    workers:2
                }
            }
        ]
      }
    ]
  }
}
</code></pre>
<ol start="4">
<li>不要使用太多的worker，因为使用worker也有开销。进程间通信很耗资源</li>
</ol>
<h3 id="394-开发环境提升构建性能">3.9.4 开发环境提升构建性能</h3>
<ol>
<li>增量编译：使用wenpack的watch mode。</li>
<li>在内存中编译：比如说：webpack-dev-server,webpack-hot-middleware,webpack-dev-middleware</li>
<li>stats.toJson加速</li>
<li>Devtool：不同的devtool配置会导致性能差异。最佳选择eval-cheap-module-source-map</li>
<li>避免在生产环境才用到的工具</li>
<li>最小化entry chunk</li>
<li>避免额外的优化步骤，所以一般配置下面的选项</li>
</ol>
<pre><code>optimization:{
    removeAvailableModules:false,
    removeEmptyChunks:false,
    splitChunks:false
}
</code></pre>
<ol start="8">
<li>输出结果避免携带路径信息</li>
</ol>
<pre><code>output:{
    pathinfo:false
}
</code></pre>
<ol start="9">
<li>node.js版本问题。node.js v8.9.10-v9.11.1的Map和Set实现存在性能回退。webpack大量使用这些数据结构，因此这次回退也会影响编译时间</li>
<li>TypeScript Loader。为loader传入transpileOnly选项，以缩短使用ts-loader时的构建时间。使用此选项会关闭类型检查。如果要再次开启类型检查请使用ForkTsCheckerWebPackPlugin。使用此插件会将检查的过程移动到单独的线程。可以加快TypeScript的类型检查和ESLint插入的速度</li>
</ol>
<pre><code>use:[
    {
        loader:'ts-loader',
        options:{
            transpileOnly:true
        }
    }
]
</code></pre>
<h3 id="395-生产环境提升构建性能">3.9.5 生产环境提升构建性能</h3>
<ol>
<li>不用sourcemap</li>
</ol>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://star2399.github.io/tag/YySyeYRSo/" class="tag">
                    Webpack
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://star2399.github.io/post/domcontentloaded-he-onload/">
                  <h3 class="post-title">
                    DOMContentLoaded和onload
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
